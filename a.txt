        if ($result === ActionResult::SUCCESS) {
            return [
                'status' => 'success',
                'message' => 'Employee created successfully.',
            ];
        } elseif ($result === ActionResult::FAILURE) {
            return [
                'status' => 'error',
                'message' => 'Failed to create the employee.',
            ];
        } else {
            return [
                'status' => 'error',
                'message' => "Error occurred: Duplicate entry for key '{$result}'.",
            ];
        }

    public function changePassword(int $employeeId, string $currentPassword, string $newPassword): ActionResult
    {
        $getPasswordQuery = "
            SELECT
                password
            FROM
                employees
            WHERE
                id = :employee_id
        ";

        try {
            $statement = $this->pdo->prepare($getPasswordQuery);

            $statement->bindValue(":employee_id", $employeeId, Helper::getPdoParameterType($employeeId));

            $statement->execute();

            $employee = $statement->fetch(PDO::FETCH_ASSOC);

            if ( ! password_verify($currentPassword, $employee["password"])) {
                return ActionResult::PASSWORD_INCORRECT;
            }

            $hashedPassword = password_hash($newPassword, PASSWORD_BCRYPT);

            $this->pdo->beginTransaction();

            $changePasswordQuery = "
                UPDATE employees
                SET
                    password = :new_password
                WHERE
                    id = :employee_id
            ";

            $updateStatement = $this->pdo->prepare($changePasswordQuery);

            $updateStatement->bindValue(":new_password", $hashedPassword, Helper::getPdoParameterType($hashedPassword));
            $updateStatement->bindValue(":employee_id" , $employeeId    , Helper::getPdoParameterType($employeeId    ));

            $updateStatement->execute();

            $this->pdo->commit();

            return ActionResult::SUCCESS;

        } catch (PDOException $exception) {
            $this->pdo->rollBack();

            error_log("Database Error: An error occurred while changing the password. " .
                      "Exception: {$exception->getMessage()}");

            return ActionResult::FAILURE;
        }
    }

        if ($result === ActionResult::FAILURE) {
            return [
                'status'  => 'error',
                'message' => 'Failed to fetch the employee.'
            ];
        }

        if (empty($result['result_set'])) {
            return [
                'status'  => 'error',
                'message' => 'Employee not found.'
            ];
        }

        return [
            'status' => 'success',
            'id'     => $result['result_set'][0]['id']
        ];

<?php

require_once __DIR__ . "/../includes/Helper.php"            ;
require_once __DIR__ . "/../includes/enums/ActionResult.php";
require_once __DIR__ . "/../includes/enums/ErrorCode.php"   ;

class OvertimeRateAssignmentDao
{
    private readonly PDO $pdo;
    private readonly OvertimeRateDao $overtimeRateDao;

    public function __construct(PDO $pdo, OvertimeRateDao $overtimeRateDao)
    {
        $this->pdo = $pdo;
        $this->overtimeRateDao = $overtimeRateDao;
    }

    public function create(OvertimeRateAssignment $overtimeRateAssignment): ActionResult
    {
        $query = "
            INSERT INTO overtime_rate_assignments (
                department_id       ,
                job_title_id        ,
                employee_id         ,
                assignment_level
            ) VALUES (
                :department_id       ,
                :job_title_id        ,
                :employee_id         ,
                :assignment_level
            )
        ";

        try {
            $this->pdo->beginTransaction();

            $statement = $this->pdo->prepare($query);

            $statement->bindValue(':department_id'       , $overtimeRateAssignment->getDepartmentId()     , Helper::getPdoParameterType($overtimeRateAssignment->getDepartmentId()     ));
            $statement->bindValue(':job_title_id'        , $overtimeRateAssignment->getJobTitleId()       , Helper::getPdoParameterType($overtimeRateAssignment->getJobTitleId()       ));
            $statement->bindValue(':employee_id'         , $overtimeRateAssignment->getEmployeeId()       , Helper::getPdoParameterType($overtimeRateAssignment->getEmployeeId()       ));
            $statement->bindValue(':assignment_level'    , $overtimeRateAssignment->getAssignmentLevel()  , Helper::getPdoParameterType($overtimeRateAssignment->getAssignmentLevel()  ));

            $statement->execute();

            $this->pdo->commit();

            return ActionResult::SUCCESS;

        } catch (PDOException $exception) {
            $this->pdo->rollBack();

            error_log("Database Error: An error occurred while creating the overtime rate assignment. " .
                      "Exception: {$exception->getMessage()}");

            return ActionResult::FAILURE;
        }
    }

    private function hasExistingAssignment(OvertimeRateAssignment $overtimeRateAssignment): ActionResult|bool
    {
        $query = "
            SELECT
                id
            FROM
                overtime_rate_assignments
            WHERE
                (:department_id IS NULL OR department_id = :department_id)
            AND (:job_title_id  IS NULL OR job_title_id  = :job_title_id )
            AND (:employee_id   IS NULL OR employee_id   = :employee_id  )
            AND assignment_level = :assignment_level
            LIMIT 1
        ";

        try {
            $statement = $this->pdo->prepare($query);

            $statement->bindValue(':department_id'   , $overtimeRateAssignment->getDepartmentId()   , Helper::getPdoParameterType($overtimeRateAssignment->getDepartmentId()   ));
            $statement->bindValue(':job_title_id'    , $overtimeRateAssignment->getJobTitleId()     , Helper::getPdoParameterType($overtimeRateAssignment->getJobTitleId()     ));
            $statement->bindValue(':employee_id'     , $overtimeRateAssignment->getEmployeeId()     , Helper::getPdoParameterType($overtimeRateAssignment->getEmployeeId()     ));
            $statement->bindValue(':assignment_level', $overtimeRateAssignment->getAssignmentLevel(), Helper::getPdoParameterType($overtimeRateAssignment->getAssignmentLevel()));

            $statement->execute();

            return $statement->rowCount() > 0;

        } catch (PDOException $exception) {
            error_log("Database Error: An error occurred while checking for an existing assignment. " .
                      "Exception: {$exception->getMessage()}");

            return ActionResult::FAILURE;
        }
    }

    public function assign(OvertimeRateAssignment $overtimeRateAssignment, array $overtimeRates): ActionResult
    {
        try {
            $this->pdo->beginTransaction();

            $hasExistingAssignment = $this->hasExistingAssignment($overtimeRateAssignment);

            if ($hasExistingAssignment === ActionResult::FAILURE) {
                return ActionResult::FAILURE;
            }

            if ($hasExistingAssignment === false) {
                $insertOvertimeRateSetQuery = "INSERT INTO overtime_rate_sets () VALUES ()";
                $this->pdo->exec($insertOvertimeRateSetQuery);

                $overtimeRateSetId = $this->pdo->lastInsertId();

                foreach ($overtimeRates as $overtimeRate) {
                    $result = $this->overtimeRateDao->create($overtimeRate, $overtimeRateSetId);

                    if ($result === ActionResult::FAILURE) {
                        $this->pdo->rollBack();

                        return ActionResult::FAILURE;
                    }
                }

                $overtimeRateAssignment = new OvertimeRateAssignment(
                    null,
                    $overtimeRateAssignment->getDepartmentId(),
                    $overtimeRateAssignment->getJobTitleId(),
                    $overtimeRateAssignment->getEmployeeId(),
                    $overtimeRateAssignment->getAssignmentLevel()
                );

                $this->create($overtimeRateAssignment);

            } else {
                foreach ($overtimeRates as $overtimeRate) {
                    $result = $this->overtimeRateDao->update($overtimeRate);

                    if ($result === ActionResult::FAILURE) {
                        $this->pdo->rollBack();

                        return ActionResult::FAILURE;
                    }
                }
            }

            $this->pdo->commit();

            return ActionResult::SUCCESS;

        } catch (PDOException $exception) {
            $this->pdo->rollBack();

            error_log("Database Error: An error occurred while assigning the overtime rates. " .
                      "Exception: {$exception->getMessage()}");

            return ActionResult::FAILURE;
        }
    }
}

<?php
try {
    $pdo = new PDO('mysql:host=localhost;dbname=your_database', 'username', 'password');
    $pdo->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);

    $employee_id = 123;
    $job_title_id = 456;
    $department_id = 789;
    $assignment_level = 'Employee';

    $id = null;

    if ($assignment_level == 'Employee') {
        $sql = "SELECT id FROM overtime_rate_assignments WHERE employee_id = :employee_id";
        $stmt = $pdo->prepare($sql);
        $stmt->bindParam(':employee_id', $employee_id);
        $stmt->execute();
        $id = $stmt->fetchColumn();

        if ($id === false) {
            $sql = "SELECT id FROM overtime_rate_assignments WHERE job_title_id = :job_title_id";
            $stmt = $pdo->prepare($sql);
            $stmt->bindParam(':job_title_id', $job_title_id);
            $stmt->execute();
            $id = $stmt->fetchColumn();

            if ($id === false) {
                $sql = "SELECT id FROM overtime_rate_assignments WHERE department_id = :department_id";
                $stmt = $pdo->prepare($sql);
                $stmt->bindParam(':department_id', $department_id);
                $stmt->execute();
                $id = $stmt->fetchColumn();

                if ($id === false) {
                    $sql = "SELECT id FROM overtime_rate_assignments WHERE assignment_level = 'All' AND department_id IS NULL AND job_title_id IS NULL AND employee_id IS NULL";
                    $stmt = $pdo->prepare($sql);
                    $stmt->execute();
                    $id = $stmt->fetchColumn();
                }
            }
        }
    } elseif ($assignment_level == 'Job Title') {
        $sql = "SELECT id FROM overtime_rate_assignments WHERE job_title_id = :job_title_id";
        $stmt = $pdo->prepare($sql);
        $stmt->bindParam(':job_title_id', $job_title_id);
        $stmt->execute();
        $id = $stmt->fetchColumn();

        if ($id === false) {
            $sql = "SELECT id FROM overtime_rate_assignments WHERE department_id = :department_id";
            $stmt = $pdo->prepare($sql);
            $stmt->bindParam(':department_id', $department_id);
            $stmt->execute();
            $id = $stmt->fetchColumn();

            if ($id === false) {
                $sql = "SELECT id FROM overtime_rate_assignments WHERE assignment_level = 'All' AND department_id IS NULL AND job_title_id IS NULL AND employee_id IS NULL";
                $stmt = $pdo->prepare($sql);
                $stmt->execute();
                $id = $stmt->fetchColumn();
            }
        }
    } elseif ($assignment_level == 'Department') {
        $sql = "SELECT id FROM overtime_rate_assignments WHERE department_id = :department_id";
        $stmt = $pdo->prepare($sql);
        $stmt->bindParam(':department_id', $department_id);
        $stmt->execute();
        $id = $stmt->fetchColumn();

        if ($id === false) {
            $sql = "SELECT id FROM overtime_rate_assignments WHERE assignment_level = 'All' AND department_id IS NULL AND job_title_id IS NULL AND employee_id IS NULL";
            $stmt = $pdo->prepare($sql);
            $stmt->execute();
            $id = $stmt->fetchColumn();
        }
    } elseif ($assignment_level == 'All') {
        $sql = "SELECT id FROM overtime_rate_assignments WHERE assignment_level = 'All' AND department_id IS NULL AND job_title_id IS NULL AND employee_id IS NULL";
        $stmt = $pdo->prepare($sql);
        $stmt->execute();
        $id = $stmt->fetchColumn();
    }

    if ($id !== false) {
        echo "ID: " . $id;
    } else {
        echo "No ID found.";
    }

} catch (PDOException $e) {
    echo "Error: " . $e->getMessage();
}
?>

        foreach ($attendanceLogPreviousAndCurrentDay as $attendanceLog) {
            $checkInTime  = $attendanceLogPreviousAndCurrentDay['check_in_time' ];
            $checkOutTime = $attendanceLogPreviousAndCurrentDay['check_out_time'];

            foreach ($workSchedules as $workSchedule) {
                $workScheduleStartTime = $workSchedule['start_time'];
                $workScheduleEndTime   = $workSchedule['end_time'  ];

                if ($checkInTime !== null && $checkOutTime !== null) {
                    // Do nothing
                } elseif (($checkInTime  === null  &&
                           $checkOutTime === null) &&

                          ($currentTime <  $workScheduleStartTime ||
                          ($currentTime >= $workScheduleStartTime &&
                           $currentTime <= $workScheduleEndTime))) {
                    $currentSchedule = $workSchedule;
                } elseif (($checkInTime  !== null  &&
                           $checkOutTime === null) &&

                           ($currentTime >  $workScheduleEndTime   ||
                           ($currentTime >= $workScheduleStartTime &&
                            $currentTime <= $workScheduleEndTime))) {
                    $currentSchedule = $workSchedule;
                }

            }










<?php
require 'vendor/autoload.php';
use RRule\RSet;
use RRule\RRule;


class RecurrenceService
{
    private $exclusionDates = [];

    // This method adds a recurrence rule to the RSet
    public function addRecurrenceRuleToRSet(RSet $rset)
    {
        $rset->addRRule(array(
            'FREQ' => 'YEARLY',
            'COUNT' => 3,
            'BYDAY' => 'TU',
            'DTSTART' => date_create('1997-09-02 09:00')
        ));
    }

    // This method adds an exclusion date to the RSet
    public function addExclusionDateToRSet(RSet $rset, $date)
    {
        $rset->addExDate($date);
    }

    // This method returns all recurrence dates between the start and end dates, excluding any dates in the exclusion list
    public function getRecurrenceDates(string $recurrenceRule, string $startDate, string $endDate): array
    {
        try {
            $parsedRecurrenceRule = $this->parseRecurrenceRule($recurrenceRule);

            $recurrence = new RRule($parsedRecurrenceRule);

            $startDate = (new DateTime($startDate))->format("Y-m-d");
            $endDate   = (new DateTime($endDate))->format("Y-m-d");

            $dates = [];

            // Get exclusion dates from the set
            $exclusionDates = $this->getExclusionDates();

            foreach ($recurrence as $occurence) {
                $date = $occurence->format("Y-m-d");

                // Skip the date if it's in the exclusion list
                if (in_array($date, $exclusionDates)) {
                    continue;
                }

                // If the date is beyond the end date, return the dates up until then
                if ($date > $endDate) {
                    return $dates;
                }

                // If the date is within the valid range, add it to the list
                if ($date >= $startDate) {
                    $dates[] = $date;
                }
            }

            return $dates;

        } catch (InvalidArgumentException $exception) {
            error_log("Invalid Argument Error: " . $exception->getMessage());
            return [];

        } catch (Exception $exception) {
            error_log("General Error: " . $exception->getMessage());
            return [];
        }
    }

    // This method parses the recurrence rule string into an array of parameters
    private function parseRecurrenceRule(string $rule): array
    {
        try {
            $rule = rtrim($rule, ";");

            $parts = explode(";", $rule);

            $parsedRule = [];

            foreach ($parts as $part) {
                [$key, $value] = explode("=", $part, 2);
                $parsedRule[$key] = $value;
            }

            return $parsedRule;

        } catch (Exception $exception) {
            error_log("Parsing Error: An error occurred while parsing the recurrence rule. " . $exception->getMessage());
            return [];
        }
    }

    // This method returns the exclusion dates (for now, itâ€™s just a placeholder)
    private function getExclusionDates(): array
    {
        return $this->exclusionDates;
    }

    // This method allows adding exclusion dates to the class
    public function addExclusionDate(string $date)
    {
        $this->exclusionDates[] = $date;
    }
}

// Example usage:

$rset = new RSet();
$recurrenceService = new RecurrenceService();

// Add recurrence rule
$recurrenceService->addRecurrenceRuleToRSet($rset);

// Add exclusion date
$recurrenceService->addExclusionDate('1997-09-04'); // Add 1997-09-04 to exclusion list

// Add exclusion date to RSet
$recurrenceService->addExclusionDateToRSet($rset, '1997-09-04 09:00');

// Get recurrence dates
$recurrenceRule = "FREQ=YEARLY;COUNT=3;BYDAY=TU;DTSTART=1997-09-02T090000";
$startDate = '1997-09-01';
$endDate = '1997-09-10';

$recurrenceDates = $recurrenceService->getRecurrenceDates($recurrenceRule, $startDate, $endDate);

// Print the recurrence dates
foreach ($recurrenceDates as $occurrence) {
    echo $occurrence . "\n";
}















<?php

require 'vendor/autoload.php';

use RRule\RSet;

function getRecurrenceDates(string $recurrenceRule, string $startDate, string $endDate): array
{
    try {
        $rset = new RSet();
        $exdates = '';

        if (preg_match('/EXDATE=([^;]+)/', $recurrenceRule, $matches)) {
            $exdates = $matches[1];
            $recurrenceRule = str_replace("EXDATE={$exdates};", '', $recurrenceRule);
        }

        $parsedRule = parseRecurrenceRule($recurrenceRule);
        $rset->addRRule($parsedRule);

        if ($exdates) {
            $excludeDates = explode(",", $exdates);
            foreach ($excludeDates as $exDate) {
                $rset->addExDate($exDate);
            }
        }

        $startDate = (new DateTime($startDate))->format("Y-m-d");
        $endDate = (new DateTime($endDate))->format("Y-m-d");

        $dates = [];
        foreach ($rset as $date) {
            $dateFormatted = $date->format("Y-m-d");

            if ($dateFormatted > $endDate) {
                return $dates;
            }

            if ($dateFormatted >= $startDate && $dateFormatted <= $endDate) {
                $dates[] = $dateFormatted;
            }
        }

        return $dates;

    } catch (InvalidArgumentException $exception) {
        error_log("Invalid Argument Error: An error occurred while processing the recurrence rule. " .
                  "Exception: {$exception->getMessage()}");

        return [];

    } catch (Exception $exception) {
        error_log("General Error: An error occurred while processing the recurrence dates. " .
                  "Exception: {$exception->getMessage()}");

        return [];
    }
}

function parseRecurrenceRule(string $rule): array
{
    $rule = rtrim($rule, ";");
    $parts = explode(";", $rule);
    $parsedRule = [];

    foreach ($parts as $part) {
        [$key, $value] = explode("=", $part, 2);
        $parsedRule[$key] = $value;
    }

    return $parsedRule;
}

$recurrenceRule = "FREQ=WEEKLY;INTERVAL=1;DTSTART=2024-11-04;BYDAY=MO,WE;EXDATE=2024-11-04,2024-11-06;";
$startDate = "2024-11-01";
$endDate = "2024-11-30";

$dates = getRecurrenceDates($recurrenceRule, $startDate, $endDate);
echo '<pre>';
print_r($dates);
echo '<pre>';


<?php

    private function fetchEmployeeAllowances(int $employeeId): ActionResult|array
    {
        $columns = [
            'id'                      ,
            'allowance_id'            ,
            'allowance_is_taxable'    ,
            'allowance_frequency'     ,
            'allowance_status'        ,
            'allowance_effective_date',
            'allowance_end_date'      ,
            'amount'
        ];

        $filterCriteria = [
            [
                'column'   => 'employee_allowance.deleted_at',
                'operator' => 'IS NULL'
            ],
            [
                'column'   => 'employee_allowance.employee_id',
                'operator' => '='
                'value'    => $employeeId
            ],
            [
                'column'   => 'allowance.status'
                'operator' => '='
                'value'    => "'Active'"
            ]
        ];

        $employeeAllowances = $this->employeeAllowanceRepository->fetchAll($columns, $filterCriteria);

        if ($employeeAllowances === ActionResult::FAILURE) {
            return ActionResult::FAILURE;
        }

        return empty($employeeAllowances)
            ? []
            : $employeeAllowances['result_set'];
    }

    private function fetchEmployeeDeductions(int $employeeId): ActionResult|array
    {
        $columns = [
            'id'                      ,
            'deduction_id'            ,
            'deduction_is_pre_tax'    ,
            'deduction_frequency'     ,
            'deduction_status'        ,
            'deduction_effective_date',
            'deduction_end_date'      ,
            'amount_type'             ,
            'amount'                  ,
        ];

        $filterCriteria = [
            [
                'column'   => 'employee_deduction.deleted_at',
                'operator' => 'IS NULL'
            ],
            [
                'column'   => 'employee_deduction.employee_id',
                'operator' => '=',
                'value'    => $employeeId
            ],
            [
                'column'   => 'deduction.status',
                'operator' => '='
                'value'    => "'Active'"
            ]
        ];

        $employeeDeductions = $this->employeeDeductionRepository->fetchAll($columns, $filterCriteria);

        if ($employeeDeductions === ActionResult::FAILURE) {
            return ActionResult::FAILURE;
        }

        return empty($employeeDeductions)
            ? []
            : $employeeDeductions['result_set'];
    }

    private function calculateSssContribution(float $salary): array
    {
        $contributionTable = [
            ["range" => [0    , 4249.99 ], "employee_share" => 180.00 , "employer_share" => 390.00 ],
            ["range" => [4250 , 4749.99 ], "employee_share" => 202.50 , "employer_share" => 437.50 ],
            ["range" => [4750 , 5249.99 ], "employee_share" => 225.00 , "employer_share" => 485.00 ],
            ["range" => [5250 , 5749.99 ], "employee_share" => 247.50 , "employer_share" => 532.50 ],
            ["range" => [5750 , 6249.99 ], "employee_share" => 270.00 , "employer_share" => 580.00 ],
            ["range" => [6250 , 6749.99 ], "employee_share" => 292.50 , "employer_share" => 627.50 ],
            ["range" => [6750 , 7249.99 ], "employee_share" => 315.00 , "employer_share" => 675.00 ],
            ["range" => [7250 , 7749.99 ], "employee_share" => 337.50 , "employer_share" => 722.50 ],
            ["range" => [7750 , 8249.99 ], "employee_share" => 360.00 , "employer_share" => 770.00 ],
            ["range" => [8250 , 8749.99 ], "employee_share" => 382.50 , "employer_share" => 817.50 ],
            ["range" => [8750 , 9249.99 ], "employee_share" => 405.00 , "employer_share" => 865.00 ],
            ["range" => [9250 , 9749.99 ], "employee_share" => 427.50 , "employer_share" => 912.50 ],
            ["range" => [9750 , 10249.99], "employee_share" => 450.00 , "employer_share" => 960.00 ],
            ["range" => [10250, 10749.99], "employee_share" => 472.50 , "employer_share" => 1007.50],
            ["range" => [10750, 11249.99], "employee_share" => 495.00 , "employer_share" => 1055.00],
            ["range" => [11250, 11749.99], "employee_share" => 517.50 , "employer_share" => 1102.50],
            ["range" => [11750, 12249.99], "employee_share" => 540.00 , "employer_share" => 1150.00],
            ["range" => [12250, 12749.99], "employee_share" => 562.50 , "employer_share" => 1197.50],
            ["range" => [12750, 13249.99], "employee_share" => 585.00 , "employer_share" => 1245.00],
            ["range" => [13250, 13749.99], "employee_share" => 607.50 , "employer_share" => 1292.50],
            ["range" => [13750, 14249.99], "employee_share" => 630.00 , "employer_share" => 1340.00],
            ["range" => [14250, 14749.99], "employee_share" => 652.50 , "employer_share" => 1387.50],
            ["range" => [14750, 15249.99], "employee_share" => 675.00 , "employer_share" => 1455.00],
            ["range" => [15250, 15749.99], "employee_share" => 697.50 , "employer_share" => 1502.50],
            ["range" => [15750, 16249.99], "employee_share" => 720.00 , "employer_share" => 1550.00],
            ["range" => [16250, 16749.99], "employee_share" => 742.50 , "employer_share" => 1597.50],
            ["range" => [16750, 17249.99], "employee_share" => 765.00 , "employer_share" => 1645.00],
            ["range" => [17250, 17749.99], "employee_share" => 787.50 , "employer_share" => 1692.50],
            ["range" => [17750, 18249.99], "employee_share" => 810.00 , "employer_share" => 1740.00],
            ["range" => [18250, 18749.99], "employee_share" => 832.50 , "employer_share" => 1787.50],
            ["range" => [18750, 19249.99], "employee_share" => 855.00 , "employer_share" => 1835.00],
            ["range" => [19250, 19749.99], "employee_share" => 877.50 , "employer_share" => 1882.50],
            ["range" => [19750, 20249.99], "employee_share" => 900.00 , "employer_share" => 1930.00],
            ["range" => [20250, 20749.99], "employee_share" => 922.50 , "employer_share" => 1977.50],
            ["range" => [20750, 21249.99], "employee_share" => 945.00 , "employer_share" => 2025.00],
            ["range" => [21250, 21749.99], "employee_share" => 967.50 , "employer_share" => 2072.50],
            ["range" => [21750, 22249.99], "employee_share" => 990.00 , "employer_share" => 2120.00],
            ["range" => [22250, 22749.99], "employee_share" => 1012.50, "employer_share" => 2167.50],
            ["range" => [22750, 23249.99], "employee_share" => 1035.00, "employer_share" => 2215.00],
            ["range" => [23250, 23749.99], "employee_share" => 1057.50, "employer_share" => 2262.50],
            ["range" => [23750, 24249.99], "employee_share" => 1080.00, "employer_share" => 2310.00],
            ["range" => [24250, 24749.99], "employee_share" => 1102.50, "employer_share" => 2357.50],
            ["range" => [24750, 25249.99], "employee_share" => 1125.00, "employer_share" => 2405.00],
            ["range" => [25250, 25749.99], "employee_share" => 1147.50, "employer_share" => 2452.50],
            ["range" => [25750, 26249.99], "employee_share" => 1170.00, "employer_share" => 2500.00],
            ["range" => [26250, 26749.99], "employee_share" => 1192.50, "employer_share" => 2547.50],
            ["range" => [26750, 27249.99], "employee_share" => 1215.00, "employer_share" => 2595.00],
            ["range" => [27250, 27749.99], "employee_share" => 1237.50, "employer_share" => 2642.50],
            ["range" => [27750, 28249.99], "employee_share" => 1260.00, "employer_share" => 2690.00],
            ["range" => [28250, 28749.99], "employee_share" => 1282.50, "employer_share" => 2737.50],
            ["range" => [28750, 29249.99], "employee_share" => 1305.00, "employer_share" => 2785.00],
            ["range" => [29250, 29749.99], "employee_share" => 1327.50, "employer_share" => 2832.50],
            ["range" => [29750, "Over"  ], "employee_share" => 1350.00, "employer_share" => 2880.00]
        ];

        foreach ($contributionTable as $row) {
            if ($row['range'][1] === 'Over') {
                if ($salary >= $row['range'][0]) {
                    return [
                        'employee_share' => $row['employee_share'],
                        'employer_share' => $row['employer_share']
                    ];
                }
            } else {
                if ($salary >= $row['range'][0] && $salary <= $row['range'][1]) {
                    return [
                        'employee_share' => $row['employee_share'],
                        'employer_share' => $row['employer_share']
                    ];
                }
            }
        }

        return [];
    }

    private function calculatePhilhealthContribution(float $salary, int $year): array
    {
        $employeeShare = 0.00;
        $employerShare = 0.00;

        if ($year === 2024 || $year === 2025) {
            if ($salary <= 10000.00) {
                $employeeShare = 500.00;
                $employerShare = 500.00;
            } elseif ($salary >= 10000.01 && $salary <= 99999.99) {
                $employeeShare = max(500.00, $salary * 0.05);
                $employerShare = max(500.00, $salary * 0.05);

                if ($employeeShare > 5000.00) {
                    $employeeShare = 5000.00;
                }

                if ($employerShare > 5000.00) {
                    $employerShare = 5000.00;
                }
            }
        }

        return [
            'employee_share' => $employeeShare,
            'employer_share' => $employerShare
        ];
    }

    private function calculatePagibigFundContribution(float $salary): array
    {
        $employeeShare = 0.00;
        $employerShare = 0.00;

        if ($salary <= 1500) {
            $employeeShare = $salary * 0.01;
            $employerShare = $salary * 0.02;
        } else {
            $employeeShare = $salary * 0.02;
            $employerShare = $salary * 0.02;
        }

        return [
            'employeeShare' => $employeeShare,
            'employerShare' => $employerShare
        ];
    }

    private function calculateWithholdingTax(float $compensation, string $frequency): float
    {
        $withholdingTax = 0.00;

        switch ($frequency) {
            case 'daily':
                if ($compensation <= 685.00) {
                    $withholdingTax = 0.00;
                } elseif ($compensation <= 1095.00) {
                    $withholdingTax = ($compensation - 685.00) * 0.15;
                } elseif ($compensation <= 2191.00) {
                    $withholdingTax = 61.65 + ($compensation - 1095.00) * 0.20;
                } elseif ($compensation <= 5478.00) {
                    $withholdingTax = 280.85 + ($compensation - 2191.00) * 0.25;
                } elseif ($compensation <= 21917.00) {
                    $withholdingTax = 1102.60 + ($compensation - 5478.00) * 0.30;
                } else {
                    $withholdingTax = 6034.30 + ($compensation - 21917.00) * 0.35;
                }
                break;

            case 'weekly':
                if ($compensation <= 4808.00) {
                    $withholdingTax = 0.00;
                } elseif ($compensation <= 7691.00) {
                    $withholdingTax = ($compensation - 4808.00) * 0.15;
                } elseif ($compensation <= 15384.00) {
                    $withholdingTax = 432.60 + ($compensation - 7691.00) * 0.20;
                } elseif ($compensation <= 38461.00) {
                    $withholdingTax = 1971.20 + ($compensation - 15384.00) * 0.25;
                } elseif ($compensation <= 153845.00) {
                    $withholdingTax = 7740.45 + ($compensation - 38461.00) * 0.30;
                } else {
                    $withholdingTax = 42355.65 + ($compensation - 153845.00) * 0.35;
                }
                break;

            case 'biweekly':
                if ($compensation <= 9616.00) {
                    $withholdingTax = 0.00;
                } elseif ($compensation <= 15382.00) {
                    $withholdingTax = ($compensation - 9616.00) * 0.15;
                } elseif ($compensation <= 30768.00) {
                    $withholdingTax = 865.20 + ($compensation - 15382.00) * 0.20;
                } elseif ($compensation <= 76922.00) {
                    $withholdingTax = 3942.40 + ($compensation - 30768.00) * 0.25;
                } elseif ($compensation <= 307690.00) {
                    $withholdingTax = 15480.90 + ($compensation - 76922.00) * 0.30;
                } else {
                    $withholdingTax = 84671.30 + ($compensation - 307690.00) * 0.35;
                }
                break;

            case 'semi-monthly':
                if ($compensation <= 10417.00) {
                    $withholdingTax = 0.00;
                } elseif ($compensation <= 16666.00) {
                    $withholdingTax = ($compensation - 10417.00) * 0.15;
                } elseif ($compensation <= 33332.00) {
                    $withholdingTax = 937.50 + ($compensation - 16666.00) * 0.20;
                } elseif ($compensation <= 83332.00) {
                    $withholdingTax = 4270.70 + ($compensation - 33332.00) * 0.25;
                } elseif ($compensation <= 333332.00) {
                    $withholdingTax = 16770.70 + ($compensation - 83332.00) * 0.30;
                } else {
                    $withholdingTax = 91770.70 + ($compensation - 333332.00) * 0.35;
                }
                break;

            case 'monthly':
                if ($compensation <= 20833.00) {
                    $withholdingTax = 0.00;
                } elseif ($compensation <= 33332.00) {
                    $withholdingTax = ($compensation - 20833.00) * 0.15;
                } elseif ($compensation <= 66666.00) {
                    $withholdingTax = 1875.00 + ($compensation - 33332.00) * 0.20;
                } elseif ($compensation <= 166666.00) {
                    $withholdingTax = 8541.80 + ($compensation - 66666.00) * 0.25;
                } elseif ($compensation <= 666666.00) {
                    $withholdingTax = 33541.80 + ($compensation - 166666.00) * 0.30;
                } else {
                    $withholdingTax = 183541.80 + ($compensation - 666666.00) * 0.35;
                }
                break;

            default:
                return "Invalid payment period. Please specify 'daily', 'weekly', 'semi-monthly', or 'monthly'.";
        }

        return round($withholdingTax, 2);
    }

<?php

public function generatePaySlips(PayrollGroup $payrollGroup): array
	{
		$columns = [
			'id'           ,
			'hourly_rate'  ,
			'annual_salary'
		];

		$filterCriteria = [
			[
				'column'   => 'employee.access_role',
				'operator' => '!=',
				'value'    => "'Admin'"
			],
			[
				'column'   => 'employee.payroll_group_id',
				'operator' => '=',
				'value'    => $payrollGroup->getId()
			],
		];

		$employees = $this->employeeRepository->fetchAll($columns, $filterCriteria);

		if ($employees === ActionResult::FAILURE) {
			return [
				'status'  => 'error',
				'message' => ''
			];
		}

		if (empty($employees)) {
			return [
				'status'  => 'error',
				'message' => ''
			];
		}

		$employees = $employees['result_set'];

        $cutoffStartDate = new DateTime($cutoffStartDate);
        $cutoffEndDate   = new DateTime($cutoffEndDate  );

		foreach ($employees as $employee) {
		    $employeeId = $employee['id'];

		    $workSchedules = $this->workScheduleRepository->getEmployeeWorkSchedules(
		        $employeeId,
		        $cutoffStartDate->format('Y-m-d'),
		        $cutoffEndDate->format('Y-m-d')
            );

            $columns = [];

            $filterCriteria = [
                [
                    'column'   => 'work_schedule.employee_id',
                    'operator' => '=',
                    'value'    => $employeeId
                ],
                [
                    'column'   => 'attendance.date',
                    'operator' => '>=',
                    'value'    => $cutoffStartDate->format('Y-m-d')
                ],
                                [
                    'column'   => 'attendance.date',
                    'operator' => '<=',
                    'value'    =>  $cutoffEndDate->format('Y-m-d')
                ]
            ];

            $attendanceRecords = $this->attendanceRepository->fetchAll($columns, $filterCriteria);

            if ($attendanceRecords === ActionResult::FAILURE) {
    			return [
    				'status'  => 'error',
    				'message' => ''
    			];
    		}
		}
	}

    private function fetchEmployeeAllowances(int $employeeId): ActionResult|array
    {
        $columns = [
            'id'                      ,
            'allowance_id'            ,
            'allowance_is_taxable'    ,
            'allowance_frequency'     ,
            'allowance_status'        ,
            'allowance_effective_date',
            'allowance_end_date'      ,
            'amount'
        ];

        $filterCriteria = [
            [
                'column'   => 'employee_allowance.deleted_at',
                'operator' => 'IS NULL'
            ],
            [
                'column'   => 'employee_allowance.employee_id',
                'operator' => '='
                'value'    => $employeeId
            ],
            [
                'column'   => 'allowance.status'
                'operator' => '='
                'value'    => "'Active'"
            ]
        ];

        $employeeAllowances = $this->employeeAllowanceRepository->fetchAll($columns, $filterCriteria);

        if ($employeeAllowances === ActionResult::FAILURE) {
            return ActionResult::FAILURE;
        }

        return empty($employeeAllowances)
            ? []
            : $employeeAllowances['result_set'];
    }


<?php

    public function generatePaySlips(PayrollGroup $payrollGroup, string $cutoffStartDate, string $cutoffEndDate): array|null
	{
		$employeeColumns = [
			'id'           ,
			'job_title_id' ,
			'department_id',
			'hourly_rate'  ,
			'annual_salary'
		];

		$filterCriteria = [
			[
				'column'   => 'employee.access_role',
				'operator' => '!=',
				'value'    => "'Admin'"
			],
			[
				'column'   => 'employee.payroll_group_id',
				'operator' => '=',
				'value'    => $payrollGroup->getId()
			],
		];

		$employees = $this->employeeRepository->fetchAll($employeeColumns, $filterCriteria);

		if ($employees === ActionResult::FAILURE) {
			return [
				'status'  => 'error',
				'message' => 'An unexpected error occurred. Please try again later.'
			];
		}

		if (empty($employees) || empty($employees['result_set'])) {
			return null;
		}

		$employees = $employees['result_set'];

        $cutoffStartDate = new DateTime($cutoffStartDate);
        $cutoffEndDate   = new DateTime($cutoffEndDate  );

		foreach ($employees as $employee) {
		    $employeeId   = $employee['id'           ];
		    $jobTitleId   = $employee['job_title_id' ];
		    $departmentId = $employee['department_id'];

		    $workSchedules = $this->workScheduleRepository->getEmployeeWorkSchedules(
		        $employeeId,
		        $cutoffStartDate->format('Y-m-d'),
		        $cutoffEndDate->format('Y-m-d')
            );

            if ($workSchedules === ActionResult::FAILURE) {
    			return [
    				'status'  => 'error',
    				'message' => 'An unexpected error occurred. Please try again later.'
    			];
    		}

            if ( ! empty($workSchedules)) {
                $attendanceColumns = [];

                $filterCriteria = [
                    [
                        'column'   => 'work_schedule.employee_id',
                        'operator' => '=',
                        'value'    => $employeeId
                    ],
                    [
                        'column'   => 'attendance.date',
                        'operator' => '>=',
                        'value'    => $cutoffStartDate->format('Y-m-d')
                    ],
                                    [
                        'column'   => 'attendance.date',
                        'operator' => '<=',
                        'value'    =>  $cutoffEndDate->format('Y-m-d')
                    ]
                ];

                $attendanceRecords = $this->attendanceRepository->fetchAll($attendanceColumns, $filterCriteria);

                if ($attendanceRecords === ActionResult::FAILURE) {
        			return [
        				'status'  => 'error',
        				'message' => 'An unexpected error occurred. Please try again later.'
        			];
        		}

                if ( ! empty($attendanceRecords)) {
                    $records = [];

                    foreach ($workSchedules as $date => $schedules) {
                        foreach ($schedules as $workSchedule) {
                            $isAttendanceRecordFound = false;

                            foreach ($attendanceRecords as $attendanceRecord) {
                                if ($attendanceRecord['date'] === $date && $attendanceRecord['work_schedule_id'] === $workSchedule['id']) {
                                    $isAttendanceRecordFound = true;

                                    $records[$date][] = [
                                        'work_schedule'     => $workSchedule    ,
                                        'attendance_record' => $attendanceRecord
                                    ];

                                    break;
                                }
                            }

                            if ( ! $isAttendanceRecordFound) {
                                $records[$date][] = [
                                    'work_schedule'     => $workSchedule,
                                    'attendance_record' => []
                                ];
                            }
                        }
                    }

                    $overtimeRateAssignment = new OvertimeRateAssignment(
                        id          : null         ,
                        departmentId: $departmentId,
                        jobTitleId  : $jobTitleId  ,
                        employeeId  : $employeeId
                    );

                    $overtimeRateAssignmentId = $this->overtimeRateAssignmentRepository->findId($overtimeRateAssignment);

                    if ($overtimeRateAssignmentId === ActionResult::FAILURE) {
            			return [
            				'status'  => 'error',
            				'message' => 'An unexpected error occurred. Please try again later.'
            			];
                    }

                    $overtimeRates = $this->overtimeRateRepository->fetchOvertimeRates( (int) $overtimeRateAssignmentId);

                    if ($overtimeRates === ActionResult::FAILURE) {
            			return [
            				'status'  => 'error',
            				'message' => 'An unexpected error occurred. Please try again later.'
            			];
                    }


                }
            }
		}
	}

    private function fetchEmployeeAllowances(int $employeeId): ActionResult|array
    {
        $columns = [
            'id'                      ,
            'allowance_id'            ,
            'allowance_is_taxable'    ,
            'allowance_frequency'     ,
            'allowance_status'        ,
            'allowance_effective_date',
            'allowance_end_date'      ,
            'amount'
        ];

        $filterCriteria = [
            [
                'column'   => 'employee_allowance.deleted_at',
                'operator' => 'IS NULL'
            ],
            [
                'column'   => 'employee_allowance.employee_id',
                'operator' => '='
                'value'    => $employeeId
            ],
            [
                'column'   => 'allowance.status'
                'operator' => '='
                'value'    => "'Active'"
            ]
        ];

        $employeeAllowances = $this->employeeAllowanceRepository->fetchAll($columns, $filterCriteria);

        if ($employeeAllowances === ActionResult::FAILURE) {
            return ActionResult::FAILURE;
        }

        return empty($employeeAllowances)
            ? []
            : $employeeAllowances['result_set'];
    }

<?php

function getHolidayDatesForPeriod(string $startDate, string $endDate, array $holidays): array
{
    $datesMarkedAsHoliday = [];

    $startDateObj = new DateTime($startDate);
    $endDateObj   = new DateTime($endDate);
    $period       = new DatePeriod($startDateObj, new DateInterval('P1D'), $endDateObj->modify('+1 day'));

    // Initialize the array with date keys
    foreach ($period as $date) {
        $datesMarkedAsHoliday[$date->format('Y-m-d')] = [];
    }

    foreach ($holidays as $holiday) {
        $holidayStartDate = new DateTime($holiday['start_date']);
        $holidayEndDate   = new DateTime($holiday['end_date']);
        $holidayPeriod    = new DatePeriod($holidayStartDate, new DateInterval('P1D'), $holidayEndDate->modify('+1 day'));

        if ($holiday['is_recurring_annually']) {
            foreach ($holidayPeriod as $holidayDate) {
                $monthDay = $holidayDate->format('m-d');

                foreach ($period as $date) {
                    if ($date->format('m-d') === $monthDay) {
                        $key = $date->format('Y-m-d');
                        if (isset($datesMarkedAsHoliday[$key])) {
                            $datesMarkedAsHoliday[$key][] = $holiday['name'];
                        }
                    }
                }
            }
        } else {
            foreach ($holidayPeriod as $holidayDate) {
                $key = $holidayDate->format('Y-m-d');
                if (isset($datesMarkedAsHoliday[$key])) {
                    $datesMarkedAsHoliday[$key][] = $holiday['name'];
                }
            }
        }
    }

    return $datesMarkedAsHoliday;
}

// Example holidays
$holidays = [
    [
        'name' => 'Christmas',
        'start_date' => '2024-11-25',
        'end_date'   => '2024-12-27',
        'is_recurring_annually' => false
    ],
    [
        'name' => 'New Year',
        'start_date' => '2024-12-25',
        'end_date'   => '2024-12-25',
        'is_recurring_annually' => true
    ],
    [
        'name' => 'Independence Day',
        'start_date' => '2024-07-04',
        'end_date'   => '2024-07-04',
        'is_recurring_annually' => true
    ]
];

$startDate = '2024-12-24';
$endDate   = '2024-12-31';

$results = getHolidayDatesForPeriod($startDate, $endDate, $holidays);
print_r($results);

<?php
$workSchedules = [
    '2024-11-13' => [
        [
            'id' => 1,
            'start_time' => '09:00:00',
            'end_time' => '12:00:00',
            'is_flextime' => '',
            'recurrence_rule' => 'FREQ=WEEKLY;INTERVAL=1;DTSTART=2024-11-04;BYDAY=MO,TU,WE,TH,FR,SA,SU;'
        ],
        [
            'id' => 2,
            'start_time' => '12:00:00',
            'end_time' => '15:00:00',
            'is_flextime' => '',
            'recurrence_rule' => 'FREQ=WEEKLY;INTERVAL=1;DTSTART=2024-11-04;BYDAY=TU,WE;'
        ],
        [
            'id' => 3,
            'start_time' => '15:00:00',
            'end_time' => '18:00:00',
            'is_flextime' => '',
            'recurrence_rule' => 'FREQ=WEEKLY;INTERVAL=1;DTSTART=2024-11-04;BYDAY=MO,WE;'
        ]
    ],
    '2024-11-14' => [
        [
            'id' => 1,
            'start_time' => '09:00:00',
            'end_time' => '12:00:00',
            'is_flextime' => '',
            'recurrence_rule' => 'FREQ=WEEKLY;INTERVAL=1;DTSTART=2024-11-04;BYDAY=MO,TU,WE,TH,FR,SA,SU;'
        ]
    ],
];

$attendanceRecords = [
    [
        'work_schedule_id' => 1,
        'date' => '2024-11-13',
    ],
    [
        'work_schedule_id' => 2,
        'date' => '2024-11-13',
    ],
    [
        'work_schedule_id' => 3,
        'date' => '2024-11-13',
    ]
];

$mappedAttendanceRecords = [];

foreach ($workSchedules as $date => $schedules) {
    foreach ($schedules as $workSchedule) {
        $attendanceFound = false;

        foreach ($attendanceRecords as $attendanceRecord) {
            if ($attendanceRecord['date'] === $date && $attendanceRecord['work_schedule_id'] === $workSchedule['id']) {
                $attendanceFound = true;
                $mappedAttendanceRecords[$date][] = [
                    'work_schedule' => $workSchedule,
                    'attendance_record' => $attendanceRecord
                ];
                break;
            }
        }

        if (!$attendanceFound) {
            $mappedAttendanceRecords[$date][] = [
                'work_schedule' => $workSchedule,
                'attendance_record' => []
            ];
        }
    }
}

echo '<pre>';
print_r($mappedAttendanceRecords);
echo '</pre>';
?>


                    $totalDaysPresent        = 0;
                    $totalDaysAbsent         = 0;
                    $totalPartialAbsent      = 0;
                    $totalMinutesLate        = 0;
                    $totalUndertimeInMinutes = 0;
                    $totalOvertimeHours      = 0;

                    $isWorkDay = true ;
                    $isRestDay = false;

                    foreach ($records as $date => $recordEntries) {
                        $dayOfWeek = (new DateTime($date))->format('l');

                        $isWorkDay = true ;
                        $isRestDay = false;

                        if ($dayOfWeek === 'Sunday') {
                            $isWorkDay = false;
                            $isRestDay = true ;
                        }

                        foreach ($recordEntries as $record) {

                        }
                    }

<?php
$workSchedules = [
    '2024-11-13' => [
        [
            'id' => 1,
            'start_time' => '09:00:00',
            'end_time' => '12:00:00',
            'is_flextime' => '',
            'recurrence_rule' => 'FREQ=WEEKLY;INTERVAL=1;DTSTART=2024-11-04;BYDAY=MO,TU,WE,TH,FR,SA,SU;'
        ],
        [
            'id' => 2,
            'start_time' => '12:00:00',
            'end_time' => '15:00:00',
            'is_flextime' => '',
            'recurrence_rule' => 'FREQ=WEEKLY;INTERVAL=1;DTSTART=2024-11-04;BYDAY=TU,WE;'
        ],
        [
            'id' => 3,
            'start_time' => '15:00:00',
            'end_time' => '18:00:00',
            'is_flextime' => '',
            'recurrence_rule' => 'FREQ=WEEKLY;INTERVAL=1;DTSTART=2024-11-04;BYDAY=MO,WE;'
        ]
    ],
    '2024-11-14' => [
        [
            'id' => 1,
            'start_time' => '09:00:00',
            'end_time' => '12:00:00',
            'is_flextime' => '',
            'recurrence_rule' => 'FREQ=WEEKLY;INTERVAL=1;DTSTART=2024-11-04;BYDAY=MO,TU,WE,TH,FR,SA,SU;'
        ]
    ],
];

$attendanceRecords = [
    [
        'work_schedule_id' => 1,
        'date' => '2024-11-13',
    ],
    [
        'work_schedule_id' => 2,
        'date' => '2024-11-13',
    ],
    [
        'work_schedule_id' => 3,
        'date' => '2024-11-13',
    ]
];

$mappedAttendanceRecords = [];

foreach ($workSchedules as $date => $schedules) {
    foreach ($schedules as $workSchedule) {
        $attendanceFound = false;

        foreach ($attendanceRecords as $attendanceRecord) {
            if ($attendanceRecord['date'] === $date && $attendanceRecord['work_schedule_id'] === $workSchedule['id']) {
                $attendanceFound = true;
                $mappedAttendanceRecords[$date][] = [
                    'work_schedule' => $workSchedule,
                    'attendance_record' => $attendanceRecord
                ];
                break;
            }
        }

        if (!$attendanceFound) {
            $mappedAttendanceRecords[$date][] = [
                'work_schedule' => $workSchedule,
                'attendance_record' => []
            ];
        }
    }
}

echo '<pre>';
print_r($mappedAttendanceRecords);
echo '</pre>';
?>

<?php
$workSchedules = [
    '2024-11-13' => [
        [
            'id' => 1,
            'start_time' => '09:00:00',
            'end_time' => '12:00:00',
            'is_flextime' => '',
            'recurrence_rule' => 'FREQ=WEEKLY;INTERVAL=1;DTSTART=2024-11-04;BYDAY=MO,TU,WE,TH,FR,SA,SU;'
        ],
        [
            'id' => 2,
            'start_time' => '12:00:00',
            'end_time' => '15:00:00',
            'is_flextime' => '',
            'recurrence_rule' => 'FREQ=WEEKLY;INTERVAL=1;DTSTART=2024-11-04;BYDAY=TU,WE;'
        ],
        [
            'id' => 3,
            'start_time' => '15:00:00',
            'end_time' => '18:00:00',
            'is_flextime' => '',
            'recurrence_rule' => 'FREQ=WEEKLY;INTERVAL=1;DTSTART=2024-11-04;BYDAY=MO,WE;'
        ]
    ],
    '2024-11-14' => [
        [
            'id' => 1,
            'start_time' => '09:00:00',
            'end_time' => '12:00:00',
            'is_flextime' => '',
            'recurrence_rule' => 'FREQ=WEEKLY;INTERVAL=1;DTSTART=2024-11-04;BYDAY=MO,TU,WE,TH,FR,SA,SU;'
        ]
    ]
];

$totalHours = 0;

foreach ($workSchedules as $schedules) {
    $uniqueSchedules = [];

    foreach ($schedules as $schedule) {
        $uniqueSchedules[$schedule['id']] = $schedule;
    }

    foreach ($uniqueSchedules as $schedule) {
        $startTime = new DateTime($schedule['start_time']);
        $endTime = new DateTime($schedule['end_time']);
        $interval = $startTime->diff($endTime);
        $totalHours += $interval->h + ($interval->i / 60); // Convert minutes to hours
    }
}

echo "Total Scheduled Hours: " . $totalHours . " hours";
?>

<?php

Regular Day Non-Holiday Regular Hours
Regular Day Special Holiday Regular Hours
Regular Day Regular Holiday Regular Hours
Regular Day Double Holiday Regular Hours

Regular Day Non-Holiday Overtime Hours
Regular Day Special Holiday Overtime Hours
Regular Day Regular Holiday Overtime Hours
Regular Day Double Holiday Overtime Hours

Regular Day Non-Holiday Night Differential
Regular Day Special Holiday Night Differential
Regular Day Regular Holiday Night Differential
Regular Day Double Holiday Night Differential

Regular Day Non-Holiday Night Differential + Overtime
Regular Day Special Holiday Night Differential + Overtime
Regular Day Regular Holiday Night Differential + Overtime
Regular Day Double Holiday Night Differential + Overtime

Rest Day Non-Holiday Regular Hours
Rest Day Special Holiday Regular Hours
Rest Day Regular Holiday Regular Hours
Rest Day Double Holiday Regular Hours

Rest Day Non-Holiday Overtime Hours
Rest Day Special Holiday Overtime Hours
Rest Day Regular Holiday Overtime Hours
Rest Day Double Holiday Overtime Hours

Rest Day Non-Holiday Night Differential
Rest Day Special Holiday Night Differential
Rest Day Regular Holiday Night Differential
Rest Day Double Holiday Night Differential

Rest Day Non-Holiday Night Differential + Overtime
Rest Day Special Holiday Night Differential + Overtime
Rest Day Regular Holiday Night Differential + Overtime
Rest Day Double Holiday Night Differential + Overtime

$totalDaysPresent        = 0;
$totalDaysAbsent         = 0;
$totalPartialAbsent      = 0;
$totalMinutesLate        = 0;
$totalUndertimeInMinutes = 0;

$regularDayNonHoliday

$totalOvertimeHours      = 0;

if $startTime between 6:00 am to 10:00 pm = regular hours
if $startTime between 10:00pm to 6:00 am = night differential

<?php

$attendanceRecord = [
    'check_in_time' => '2024-12-03 22:00:00',
    'check_out_time' => '2024-12-04 06:00:00'
];

$regularHours = 0;
$nightDifferentialHours = 0;

$attendanceCheckInTime = new DateTime($attendanceRecord['check_in_time']);
$attendanceCheckOutTime = new DateTime($attendanceRecord['check_out_time']);
$attendanceCheckOutTime->modify('+1 hour');

$interval = new DateInterval('PT1H');
$period = new DatePeriod($attendanceCheckInTime, $interval, $attendanceCheckOutTime);

foreach ($period as $currentTime) {
    $hour = (int)$currentTime->format('H');
    if ($hour >= 22 || $hour <= 6) {
        $nightDifferentialHours++;
    } else {
        $regularHours++;
    }

    echo $currentTime->format('Y-m-d H:i:s') . "\n";
}

echo "Regular Hours: $regularHours\n";
echo "Night Differential Hours: $nightDifferentialHours\n";


                    $totalScheduledHours = 0;

                    $uniqueWorkSchedules = [];

                    foreach ($workSchedules as $date => $schedules) {
                        $uniqueWorkSchedules = [];

                        foreach ($schedules as $workSchedule) {
                            $uniqueWorkSchedules[$workSchedule['id']] = $workSchedule;
                        }

                        foreach ($uniqueWorkSchedules as $uniqueWorkSchedule) {
                            $startTime = new DateTime($uniqueWorkSchedule['start_time']);
                            $endTime   = new DateTime($uniqueWorkSchedule['end_time'  ]);

                            $interval = $startTime->diff($endTime);
                            $totalScheduledHours += $interval->h + ($interval->i / 60);
                        }
                    }



                    $hourSummary = [
                        'regular_day' => [
                            'non_holiday' => [
                                'regular_hours'               => 0,
                                'overtime_hours'              => 0,
                                'night_differential'          => 0,
                                'night_differential_overtime' => 0
                            ],
                            'special_holiday' => [
                                'regular_hours'               => 0,
                                'overtime_hours'              => 0,
                                'night_differential'          => 0,
                                'night_differential_overtime' => 0
                            ],
                            'regular_holiday' => [
                                'regular_hours'               => 0,
                                'overtime_hours'              => 0,
                                'night_differential'          => 0,
                                'night_differential_overtime' => 0
                            ],
                            'double_holiday' => [
                                'regular_hours'               => 0,
                                'overtime_hours'              => 0,
                                'night_differential'          => 0,
                                'night_differential_overtime' => 0
                            ]
                        ],
                        'rest_day' => [
                            'non_holiday' => [
                                'regular_hours'               => 0,
                                'overtime_hours'              => 0,
                                'night_differential'          => 0,
                                'night_differential_overtime' => 0
                            ],
                            'special_holiday' => [
                                'regular_hours'               => 0,
                                'overtime_hours'              => 0,
                                'night_differential'          => 0,
                                'night_differential_overtime' => 0
                            ],
                            'regular_holiday' => [
                                'regular_hours'               => 0,
                                'overtime_hours'              => 0,
                                'night_differential'          => 0,
                                'night_differential_overtime' => 0
                            ],
                            'double_holiday' => [
                                'regular_hours'               => 0,
                                'overtime_hours'              => 0,
                                'night_differential'          => 0,
                                'night_differential_overtime' => 0
                            ]
                        ]
                    ];

                    foreach ($records as $date => $recordEntries) {
                        $dayOfWeek = (new DateTime($date))->format('l');
                        $dayType   = $dayOfWeek === 'Sunday' ? 'rest_day' : 'regular_day';

                        $isHoliday = empty($datesMarkedAsHoliday[$date]);
                        $holidayType = 'non_holiday';

                        if ($isHoliday) {
                            if (count($datesMarkedAsHoliday[$date]) > 1) {
                                $holidayType = 'double_holiday';
                            } elseif ($datesMarkedAsHoliday[$date]['is_paid']) {
                                $holidayType = 'regular_holiday';
                            } else {
                                $holidayType = 'special_holiday';
                            }
                        }

                        foreach ($recordEntries as $record) {
                            $workSchedule     = $record['work_schedule'    ];
                            $attendanceRecord = $record['attendance_record'];

                            $attendanceCheckInTime  = new DateTime($attendanceRecord['check_in_time' ]);
                            $attendanceCheckOutTime = new DateTime($attendanceRecord['check_out_time']);

                            $isOvertimeApproved = $attendanceRecord['is_overtime_approved'];
                        }
                    }

                            $employeeBreakColumns = [
                                'id'                                ,
                                'employee_id'                       ,
                                'break_schedule_id'                 ,
                                'break_schedule_start_time'         ,
                                'break_schedule_is_flexible'        ,
                                'break_schedule_earliest_start_time',
                                'break_schedule_latest_end_time'    ,
                                'start_time'                        ,
                                'end_time'                          ,
                                'break_duration_in_minutes'         ,
                                'is_require_break_in_and_break_out'
                            ];

                            $filterCriteria = [
                                [
                                    'column'   => 'work_schedule.employee_id',
                                    'operator' => '='                        ,
                                    'value'    => $employeeId
                                ],
                                [
                                    'column'      => 'employee_break.created_at',
                                    'operator'    => 'BETWEEN'                  ,
                                    'lower_bound' => $workScheduleStartTime->format('Y-m-d H:i:s'),
                                    'upper_bound' => $workScheduleEndTime->format('Y-m-d H:i:s')
                                ]
                            ];

                            $sortCriteria = [
                                [
                                    'column'    => 'employee_break.created_at',
                                    'direction' => 'DESC'
                                ],
                                [
                                    'column'    => 'employee_break.start_time',
                                    'direction' => 'DESC'
                                ]
                            ];

                            $result = $this->employeeBreakRepository->fetchAllEmployeeBreaks(
                                columns       : $employeeBreakColumns,
                                filterCriteria: $filterCriteria      ,
                                sortCriteria  : $sortCriteria
                            );

                            if ($result === ActionResult::FAILURE) {
                                return [
                                    'status'  => 'error',
                                    'message' => 'An unexpected error occurred. Please try again later.'
                                ];
                            }

                            $employeeBreaks = $result['result_set'];


<?php

$workSchedule = [
    'start_time' => '2024-12-03 08:00:00',
    'end_time'   => '2024-12-03 17:00:00'
];

$attendanceRecord = [
    'check_in_time' => '2024-12-03 08:00:00',
    'check_out_time' => '2024-12-04 08:00:00'
];

$regularHours = 0;
$regularOvertimeHours = 0;
$nightDifferentialHours = 0;
$nightDifferentialOvertime = 0;

$attendanceCheckInTime = new DateTime($attendanceRecord['check_in_time']);
$attendanceCheckOutTime = new DateTime($attendanceRecord['check_out_time']);
$workScheduleStartTime = new DateTime($workSchedule['start_time']);
$workScheduleEndTime = new DateTime($workSchedule['end_time']);

$isOvertimeApproved = 1;

// Handle start time fractional minutes
$startMinutes = (int)$attendanceCheckInTime->format('i');
if ($startMinutes > 0) {
    $remainingMinutes = 60 - $startMinutes;
    $currentHour = (int)$attendanceCheckInTime->format('H');
    $isNightShift = ($currentHour >= 22 || $currentHour < 6);

    if ($isNightShift) {
        if ($attendanceCheckInTime >= $workScheduleEndTime && $isOvertimeApproved) {
            $nightDifferentialOvertime += $remainingMinutes / 60;
        } else {
            $nightDifferentialHours += $remainingMinutes / 60;
        }
    } else {
        if ($attendanceCheckInTime >= $workScheduleEndTime && $isOvertimeApproved) {
            $regularOvertimeHours += $remainingMinutes / 60;
        } else {
            $regularHours += $remainingMinutes / 60;
        }
    }

    $attendanceCheckInTime->modify('+' . $remainingMinutes . ' minutes');
}

$endMinutes = (int)$attendanceCheckOutTime->format('i');
if ($endMinutes > 0) {
    $roundedCheckOutTime = clone $attendanceCheckOutTime;
    $roundedCheckOutTime->modify('-' . $endMinutes . ' minutes');

    $currentHour = (int)$attendanceCheckOutTime->format('H');
    $isNightShift = ($currentHour >= 22 || $currentHour < 6);

    if ($isNightShift) {
        if ($roundedCheckOutTime >= $workScheduleEndTime && $isOvertimeApproved) {
            $nightDifferentialOvertime += $endMinutes / 60;
        } else {
            $nightDifferentialHours += $endMinutes / 60;
        }
    } else {
        if ($roundedCheckOutTime >= $workScheduleEndTime && $isOvertimeApproved) {
            $regularOvertimeHours += $endMinutes / 60;
        } else {
            $regularHours += $endMinutes / 60;
        }
    }

    $attendanceCheckOutTime = $roundedCheckOutTime;
}

$interval = new DateInterval('PT1H');
$period = new DatePeriod($attendanceCheckInTime, $interval, $attendanceCheckOutTime);

foreach ($period as $currentTime) {
    $hour = (int)$currentTime->format('H');
    $isNightShift = ($hour >= 22 || $hour < 6);

    if ($isNightShift) {
        if ($currentTime >= $workScheduleEndTime) {
            if ($isOvertimeApproved) {
                $nightDifferentialOvertime++;
            }
        } else {
            $nightDifferentialHours++;
        }
    } else {
        if ($currentTime >= $workScheduleEndTime) {
            if ($isOvertimeApproved) {
                $regularOvertimeHours++;
            }
        } else {
            $regularHours++;
        }
    }

    //echo $currentTime->format('Y-m-d H:i:s') . "\n";
}

echo "Regular Hours: $regularHours\n";
echo "Regular Overtime Hours: $regularOvertimeHours\n";
echo "Night Differential Hours: $nightDifferentialHours\n";
echo "Night Differential Overtime: $nightDifferentialOvertime\n";

<?php

$records = [
    '2024-12-01' => [
        [
            'work_schedule' => [
                'start_time' => '2024-12-01 08:00:00',
                'end_time' => '2024-12-01 17:00:00'
            ],
            'attendance_record' => [
                'date' => '2024-12-01',
                'check_in_time' => '2024-12-01 08:00:00',
                'check_out_time' => '2024-12-02 00:00:00',
                'is_overtime_approved' => true
            ]
        ]
    ],
    '2024-12-02' => [
    ],
    '2024-12-03' => [
        [
            'work_schedule' => [
                'start_time' => '09:00:00',
                'end_time' => '18:00:00'
            ],
            'attendance_record' => [
                'date' => '2024-12-03',
                'check_in_time' => '09:15:00',
                'check_out_time' => '17:45:00',
                'is_overtime_approved' => false
            ]
        ]
    ]
];

$datesMarkedAsHoliday = [
    '2024-12-02' => [
        ['is_paid' => true]
    ]
];

$hourSummary = [
    'regular_day' => [
        'non_holiday' => [
            'regular_hours' => 0,
            'overtime_hours' => 0,
            'night_differential' => 0,
            'night_differential_overtime' => 0
        ],
        'special_holiday' => [
            'regular_hours' => 0,
            'overtime_hours' => 0,
            'night_differential' => 0,
            'night_differential_overtime' => 0
        ],
        'regular_holiday' => [
            'regular_hours' => 0,
            'overtime_hours' => 0,
            'night_differential' => 0,
            'night_differential_overtime' => 0
        ],
        'double_holiday' => [
            'regular_hours' => 0,
            'overtime_hours' => 0,
            'night_differential' => 0,
            'night_differential_overtime' => 0
        ]
    ],
    'rest_day' => [
        'non_holiday' => [
            'regular_hours' => 0,
            'overtime_hours' => 0,
            'night_differential' => 0,
            'night_differential_overtime' => 0
        ],
        'special_holiday' => [
            'regular_hours' => 0,
            'overtime_hours' => 0,
            'night_differential' => 0,
            'night_differential_overtime' => 0
        ],
        'regular_holiday' => [
            'regular_hours' => 0,
            'overtime_hours' => 0,
            'night_differential' => 0,
            'night_differential_overtime' => 0
        ],
        'double_holiday' => [
            'regular_hours' => 0,
            'overtime_hours' => 0,
            'night_differential' => 0,
            'night_differential_overtime' => 0
        ]
    ]
];

foreach ($records as $date => $recordEntries) {
    $dayOfWeek = (new DateTime($date))->format('l');
    $dayType = $dayOfWeek === 'Sunday' ? 'rest_day' : 'regular_day';

    // Check if the date exists in $datesMarkedAsHoliday, if not, set it to an empty array
    $isHoliday = isset($datesMarkedAsHoliday[$date]) ? $datesMarkedAsHoliday[$date] : [];
    $holidayType = 'non_holiday';

    if (!empty($isHoliday)) {
        if (count($isHoliday) > 1) {
            $holidayType = 'double_holiday';
        } elseif ($isHoliday[0]['is_paid']) {
            $holidayType = 'regular_holiday';
        } else {
            $holidayType = 'special_holiday';
        }
    }

    foreach ($recordEntries as $record) {
        $workSchedule = $record['work_schedule'];
        $attendanceRecord = $record['attendance_record'];

        $workScheduleStartTime = new DateTime($workSchedule['start_time']);
        $workScheduleEndTime = new DateTime($workSchedule['end_time']);

        $workScheduleStartTime = new DateTime($attendanceRecord['date'] . ' ' . (new DateTime($workSchedule['start_time']))->format('H:i:s'));
        $workScheduleEndTime = new DateTime($attendanceRecord['date'] . ' ' . (new DateTime($workSchedule['end_time']))->format('H:i:s'));

        if ($workScheduleEndTime->format('H:i:s') < $workScheduleStartTime->format('H:i:s')) {
            $workScheduleEndTime->modify('+1 day');
        }

        $attendanceCheckInTime = new DateTime($attendanceRecord['check_in_time']);
        $attendanceCheckOutTime = $attendanceRecord['check_out_time']
            ? new DateTime($attendanceRecord['check_out_time'])
            : $workScheduleEndTime;

        $isOvertimeApproved = $attendanceRecord['is_overtime_approved'];

        $startMinutes = (int)$attendanceCheckInTime->format('i');
        if ($startMinutes > 0) {
            $remainingMinutes = 60 - $startMinutes;
            $hour = (int)$attendanceCheckInTime->format('H');
            $isNightShift = ($hour >= 22 || $hour < 6);

            if ($isNightShift) {
                if ($attendanceCheckInTime >= $workScheduleEndTime) {
                    if ($isOvertimeApproved) {
                        $hourSummary[$dayType][$holidayType]['night_differential_overtime'] += $remainingMinutes / 60;
                    }
                } else {
                    $hourSummary[$dayType][$holidayType]['night_differential'] += $remainingMinutes / 60;
                }
            } else {
                if ($attendanceCheckInTime >= $workScheduleEndTime) {
                    if ($isOvertimeApproved) {
                        $hourSummary[$dayType][$holidayType]['overtime_hours'] += $remainingMinutes / 60;
                    }
                } else {
                    $hourSummary[$dayType][$holidayType]['regular_hours'] += $remainingMinutes / 60;
                }
            }

            $attendanceCheckInTime->modify('+' . $remainingMinutes . ' minutes');
        }

        $endMinutes = (int)$attendanceCheckOutTime->format('i');
        if ($endMinutes > 0) {
            $roundedCheckOutTime = clone $attendanceCheckOutTime;
            $roundedCheckOutTime->modify('-' . $endMinutes . ' minutes');

            $hour = (int)$attendanceCheckOutTime->format('H');
            $isNightShift = ($hour >= 22 || $hour < 6);

            if ($isNightShift) {
                if ($roundedCheckOutTime >= $workScheduleEndTime) {
                    if ($isOvertimeApproved) {
                        $hourSummary[$dayType][$holidayType]['night_differential_overtime'] += $endMinutes / 60;
                    }
                } else {
                    $hourSummary[$dayType][$holidayType]['night_differential'] += $endMinutes / 60;
                }
            } else {
                if ($roundedCheckOutTime >= $workScheduleEndTime) {
                    if ($isOvertimeApproved) {
                        $hourSummary[$dayType][$holidayType]['overtime_hours'] += $endMinutes / 60;
                    }
                } else {
                    $hourSummary[$dayType][$holidayType]['regular_hours'] += $endMinutes / 60;
                }
            }

            $attendanceCheckOutTime = $roundedCheckOutTime;
        }

        $dateInterval = new DateInterval('PT1H');
        $datePeriod = new DatePeriod($attendanceCheckInTime, $dateInterval, $attendanceCheckOutTime);

        foreach ($datePeriod as $currentTime) {
            $hour = (int)$currentTime->format('H');
            $isNightShift = ($hour >= 22 || $hour < 6);

            if ($isNightShift) {
                if ($currentTime >= $workScheduleEndTime) {
                    if ($isOvertimeApproved) {
                        $hourSummary[$dayType][$holidayType]['night_differential_overtime']++;
                    }
                } else {
                    $hourSummary[$dayType][$holidayType]['night_differential']++;
                }
            } else {
                if ($currentTime >= $workScheduleEndTime) {
                    if ($isOvertimeApproved) {
                        $hourSummary[$dayType][$holidayType]['overtime_hours']++;
                    }
                } else {
                    $hourSummary[$dayType][$holidayType]['regular_hours']++;
                }
            }
        }
    }
}

print_r($hourSummary);


<?php
$hourSummary = [
    'regular_day' => [
        'non_holiday' => [
            'regular_hours' => 0,
            'overtime_hours' => 0,
            'night_differential' => 0,
            'night_differential_overtime' => 0
        ],
        'special_holiday' => [
            'regular_hours' => 0,
            'overtime_hours' => 0,
            'night_differential' => 0,
            'night_differential_overtime' => 0
        ],
        'regular_holiday' => [
            'regular_hours' => 0,
            'overtime_hours' => 0,
            'night_differential' => 0,
            'night_differential_overtime' => 0
        ],
        'double_holiday' => [
            'regular_hours' => 0,
            'overtime_hours' => 0,
            'night_differential' => 0,
            'night_differential_overtime' => 0
        ]
    ],
    'rest_day' => [
        'non_holiday' => [
            'regular_hours' => 0,
            'overtime_hours' => 0,
            'night_differential' => 0,
            'night_differential_overtime' => 0
        ],
        'special_holiday' => [
            'regular_hours' => 0,
            'overtime_hours' => 0,
            'night_differential' => 0,
            'night_differential_overtime' => 0
        ],
        'regular_holiday' => [
            'regular_hours' => 0,
            'overtime_hours' => 0,
            'night_differential' => 0,
            'night_differential_overtime' => 0
        ],
        'double_holiday' => [
            'regular_hours' => 0,
            'overtime_hours' => 0,
            'night_differential' => 0,
            'night_differential_overtime' => 0
        ]
    ]
];

$records = [
    '2024-12-01' => [
        [
            'work_schedule' => [
                'start_time' => '2024-12-01 08:00:00',
                'end_time' => '2024-12-01 17:00:00',
                'is_flextime' => false
            ],
            'attendance_record' => [
                'check_in_time' => '2024-12-01 08:05:00',
                'check_out_time' => '2024-12-01 17:10:00',
                'date' => '2024-12-01',
                'is_overtime_approved' => true
            ]
        ]
    ]
];

$datesMarkedAsHoliday = [
    '2024-12-02' => [
        ['is_paid' => true]
    ]
];

foreach ($records as $date => $recordEntries) {
    $dayOfWeek = (new DateTime($date))->format('l');
    $dayType = $dayOfWeek === 'Sunday' ? 'rest_day' : 'regular_day';

    $isHoliday = empty($datesMarkedAsHoliday[$date]);
    $holidayType = 'non_holiday';

    if (!$isHoliday) {
        $holidayEntries = $datesMarkedAsHoliday[$date];

        if (is_array($holidayEntries) && count($holidayEntries) > 1) {
            $holidayType = 'double_holiday';
        } elseif (is_array($holidayEntries) && isset($holidayEntries[0]['is_paid']) && $holidayEntries[0]['is_paid']) {
            $holidayType = 'regular_holiday';
        } else {
            $holidayType = 'special_holiday';
        }
    }

    foreach ($recordEntries as $record) {
        $workSchedule = $record['work_schedule'];
        $attendanceRecord = $record['attendance_record'];

        $workScheduleStartTime = new DateTime($workSchedule['start_time']);
        $workScheduleEndTime = new DateTime($workSchedule['end_time']);

        $workScheduleStartTime = new DateTime($attendanceRecord['date'] . ' ' . (new DateTime($workSchedule['start_time']))->format('H:i:s'));
        $workScheduleEndTime = new DateTime($attendanceRecord['date'] . ' ' . (new DateTime($workSchedule['end_time']))->format('H:i:s'));

        if ($workScheduleEndTime->format('H:i:s') < $workScheduleStartTime->format('H:i:s')) {
            $workScheduleEndTime->modify('+1 day');
        }

        $attendanceCheckInTime = new DateTime($attendanceRecord['check_in_time']);
        $attendanceCheckOutTime = $attendanceRecord['check_out_time']
            ? new DateTime($attendanceRecord['check_out_time'])
            : $workScheduleEndTime;

        $gracePeriod = 15;

        if (!$workSchedule['is_flextime']) {

            if ($attendanceCheckInTime <= $workScheduleStartTime) {
                $attendanceCheckInTime = $workScheduleStartTime;
            }

            $adjustedStartTime = (clone $workScheduleStartTime)->modify("+{$gracePeriod} minutes");

            if ($attendanceCheckInTime <= $adjustedStartTime) {
                $attendanceCheckInTime = $workScheduleStartTime;
            }
        }
        $isOvertimeApproved = $attendanceRecord['is_overtime_approved'];

        $startMinutes = (int)$attendanceCheckInTime->format('i');
        if ($startMinutes > 0) {
            $remainingMinutes = 60 - $startMinutes;
            $hour = (int)$attendanceCheckInTime->format('H');
            $isNightShift = ($hour >= 22 || $hour < 6);

            if ($isNightShift) {
                if ($attendanceCheckInTime >= $workScheduleEndTime) {
                    if ($isOvertimeApproved) {
                        $hourSummary[$dayType][$holidayType]['night_differential_overtime'] += $remainingMinutes / 60;
                    }
                } else {
                    $hourSummary[$dayType][$holidayType]['night_differential'] += $remainingMinutes / 60;
                }
            } else {
                if ($attendanceCheckInTime >= $workScheduleEndTime) {
                    if ($isOvertimeApproved) {
                        $hourSummary[$dayType][$holidayType]['overtime_hours'] += $remainingMinutes / 60;
                    }
                } else {
                    $hourSummary[$dayType][$holidayType]['regular_hours'] += $remainingMinutes / 60;
                }
            }

            $attendanceCheckInTime->modify('+' . $remainingMinutes . ' minutes');
        }

        $endMinutes = (int)$attendanceCheckOutTime->format('i');
        if ($endMinutes > 0) {
            $roundedCheckOutTime = clone $attendanceCheckOutTime;
            $roundedCheckOutTime->modify('-' . $endMinutes . ' minutes');

            $hour = (int)$attendanceCheckOutTime->format('H');
            $isNightShift = ($hour >= 22 || $hour < 6);

            if ($isNightShift) {
                if ($roundedCheckOutTime >= $workScheduleEndTime) {
                    if ($isOvertimeApproved) {
                        $hourSummary[$dayType][$holidayType]['night_differential_overtime'] += $endMinutes / 60;
                    }
                } else {
                    $hourSummary[$dayType][$holidayType]['night_differential'] += $endMinutes / 60;
                }
            } else {
                if ($roundedCheckOutTime >= $workScheduleEndTime) {
                    if ($isOvertimeApproved) {
                        $hourSummary[$dayType][$holidayType]['overtime_hours'] += $endMinutes / 60;
                    }
                } else {
                    $hourSummary[$dayType][$holidayType]['regular_hours'] += $endMinutes / 60;
                }
            }

            $attendanceCheckOutTime = $roundedCheckOutTime;
        }

        $dateInterval = new DateInterval('PT1H');
        $datePeriod = new DatePeriod($attendanceCheckInTime, $dateInterval, $attendanceCheckOutTime);

        foreach ($datePeriod as $currentTime) {
            $hour = (int)$currentTime->format('H');
            $isNightShift = ($hour >= 22 || $hour < 6);

            if ($isNightShift) {
                if ($currentTime >= $workScheduleEndTime) {
                    if ($isOvertimeApproved) {
                        $hourSummary[$dayType][$holidayType]['night_differential_overtime']++;
                    }
                } else {
                    $hourSummary[$dayType][$holidayType]['night_differential']++;
                }
            } else {
                if ($currentTime >= $workScheduleEndTime) {
                    if ($isOvertimeApproved) {
                        $hourSummary[$dayType][$holidayType]['overtime_hours']++;
                    }
                } else {
                    $hourSummary[$dayType][$holidayType]['regular_hours']++;
                }
            }
        }
    }
}


print_r($hourSummary);



                    foreach ($workSchedules as $date => $schedules) {
                        foreach ($schedules as $workSchedule) {
                            $isAttendanceRecordFound = false;

                            foreach ($attendanceRecords as $attendanceRecord) {
                                if ($attendanceRecord['date'] === $date && $attendanceRecord['work_schedule_id'] === $workSchedule['id']) {
                                    $isAttendanceRecordFound = true;

                                    $records[$date][] = [
                                        'work_schedule'     => $workSchedule    ,
                                        'attendance_record' => $attendanceRecord
                                    ];

                                    break;
                                }
                            }

                            if ( ! $isAttendanceRecordFound) {
                                $records[$date][] = [
                                    'work_schedule'     => $workSchedule,
                                    'attendance_record' => []
                                ];
                            }
                        }
                    }

    public function findId(OvertimeRateAssignment $overtimeRateAssignment): ActionResult|int
    {
        $a = $overtimeRateAssignment->getEmployeeId();
        $b = $overtimeRateAssignment->getJobTitleId();
        $c = $overtimeRateAssignment->getDepartmentId();

        $query = "
            SELECT
                id
            FROM
                overtime_rate_assignments
            WHERE
                (employee_id = $a AND job_title_id = $b AND department_id = $c)
            OR
                (employee_id IS NULL        AND job_title_id = $b AND department_id = $c)
            OR
                (employee_id IS NULL        AND job_title_id IS NULL         AND department_id = $c)
            OR
                (employee_id IS NULL        AND job_title_id IS NULL         AND department_id IS NULL        )
            ORDER BY
                CASE
                    WHEN employee_id = $a AND job_title_id = $b AND department_id = $c THEN 1
                    WHEN employee_id IS NULL        AND job_title_id = $b AND department_id = $c THEN 2
                    WHEN employee_id IS NULL        AND job_title_id IS NULL         AND department_id = $c THEN 3
                    WHEN employee_id IS NULL        AND job_title_id IS NULL         AND department_id IS NULL          THEN 4
                    ELSE 5
                END
            LIMIT 1
        ";

        try {
            $statement = $this->pdo->prepare($query);

            $statement->execute();

            $result = $statement->fetchColumn();

            return $result !== false
                ? (int) $result
                : ActionResult::NO_RECORD_FOUND;

        } catch (PDOException $exception) {
            error_log("Database Error: An error occurred while fetching the ID. " .
                      "Exception: {$exception->getMessage()}");

            return ActionResult::FAILURE;
        }
    }

                    $totalScheduledHours = 0;

                    $uniqueWorkSchedules = [];

                    foreach ($workSchedules as $date => $schedules) {
                        $uniqueWorkSchedules = [];

                        foreach ($schedules as $workSchedule) {
                            $uniqueWorkSchedules[$workSchedule['id']] = $workSchedule;
                        }

                        foreach ($uniqueWorkSchedules as $uniqueWorkSchedule) {
                            $startTime = new DateTime($uniqueWorkSchedule['start_time']);
                            $endTime   = new DateTime($uniqueWorkSchedule['end_time'  ]);

                            $interval = $startTime->diff($endTime);
                            $totalScheduledHours += $interval->h + ($interval->i / 60);
                        }
                    }
foreach ($defaultBreaks as $break) {
                                        $breakStartTime = new DateTime($break['start_time']);
                                        $breakEndTime = new DateTime($break['end_time']);

                                        $dateInterval = new DateInterval('PT1H');
                                        $breakPeriod = new DatePeriod($breakStartTime, $dateInterval, $breakEndTime);
                                    }

                                    foreach ($defaultBreaks as $break) {
                                        $breakStartTime = new DateTime($break['start_time']);
                                        $breakEndTime = new DateTime($break['end_time']);

                                        $breakDurationInMinutes = $breakStartTime->diff($breakEndTime)->i;

                                        if ($breakEndTime < $breakStartTime) {
                                            $breakDurationInMinutes += 1440;
                                        }

                                        $dateInterval = new DateInterval('PT1H');
                                        $breakPeriod = new DatePeriod($breakStartTime, $dateInterval, $breakEndTime);

                                        foreach ($breakPeriod as $currentBreakTime) {
                                            $currentDate = $currentBreakTime->format('Y-m-d');
                                            $hour = (int) $currentBreakTime->format('i');

                                            $isNightShift = ($hour >= 22 || $hour < 6);

                                            $dayOfWeek = (new DateTime($currentDate))->format('l');
                                            $dayType = $dayOfWeek === 'Sunday' ? 'rest_day' : 'regular_day';

                                            $isHoliday = ! empty($datesMarkedAsHoliday[$currentDate]);
                                            $holidayType = 'non_holiday';

                                            if ($isHoliday) {
                                                if (count($datesMarkedAsHoliday[$currentDate]) > 1) {
                                                    $holidayType = 'double_holiday';
                                                } elseif ($datesMarkedAsHoliday[$currentDate]['is_paid']) {
                                                    $holidayType = 'regular_holiday';
                                                } else {
                                                    $holidayType = 'special_holiday';
                                                }
                                            }

                                            if ($isNightShift) {
                                                if (isset($hourSummary[$dayType][$holidayType]['night_differential']) && $hourSummary[$dayType][$holidayType]['night_differential'] > 0) {
                                                    $hourSummary[$dayType][$holidayType]['night_differential'] -= ($breakDurationInMinutes / 60);
                                                }
                                            } else {
                                                if (isset($hourSummary[$dayType][$holidayType]['regular_hours']) && $hourSummary[$dayType][$holidayType]['regular_hours'] > 0) {
                                                    $hourSummary[$dayType][$holidayType]['regular_hours'] -= ($breakDurationInMinutes / 60);
                                                }
                                            }
                                        }
                                    }











<?php

    public function generatePayslips(PayrollGroup $payrollGroup, string $cutoffStartDate, string $cutoffEndDate): ?array
    {
        $employees = $this->fetchEmployees($payrollGroup->getId());

        if ($employees === ActionResult::FAILURE) {
            return [
				'status'  => 'error',
				'message' => 'An unexpected error occurred. Please try again later.'
			];
        }

        if (empty($employees)) {
            return null;
        }

        foreach ($employees as $employee) {
            $this->calculate($employee, $cutoffStartDate, $cutoffEndDate);
        }
    }

    private function fetchEmployees(int $payrollGroupId): ActionResult|array
    {
        $columns = [
            'id'           ,
            'job_title_id' ,
            'department_id',
            'annual_salary',
            'hourly_rate'
        ];

        $filterCriteria = [
			[
				'column'   => 'employee.access_role',
				'operator' => '!=',
				'value'    => "'Admin'"
			],
			[
				'column'   => 'employee.payroll_group_id',
				'operator' => '=',
				'value'    => $payrollGroupId
			]
        ];

        $actionResult = $this->employeeRepository->fetchAllEmployees($columns, $filterCriteria);

        if ($actionResult === ActionResult::FAILURE) {
            return ActionResult::FAILURE;
        }

        return $actionResult['result_set'];
    }

    private function calculate(array $employee, string $cutoffStartDate, string $cutoffEndDate): array
    {
        $cutoffStartDate = new DateTime($cutoffStartDate);
        $cutoffEndDate   = new DateTime($cutoffEndDate  );

        $formattedCutoffStartDate = $cutoffStartDate->format('Y-m-d');
        $formattedCutoffEndDate   = $cutoffEndDate  ->format('Y-m-d');

        $employeeId    = $employee['id'            ];
        $jobTitleId    = $employee['job_title_id'  ];
        $departmentId  = $employee['department_id' ];
        $annualySalary = $employee['annualy_salary'];
        $hourlyRate    = $employee['hourly_rate'   ];

        $employeeWorkSchedules = $this->workScheduleRepository->getEmployeeWorkSchedules(
            $employeeId,
            $formattedCutoffStartDate,
            $formattedCutoffEndDate
        );

        if ($employeeWorkSchedules === ActionResult::FAILURE) {
            return [
				'status'  => 'error',
				'message' => 'An unexpected error occurred. Please try again later.'
			];
        }

        $employeeAttendanceRecords = $this->fetchEmployeeAttendanceRecords(
            $employeeId,
            $formattedCutoffStartDate,
            $formattedCutoffEndDate
        );

        if ($employeeAttendanceRecords === ActionResult::FAILURE) {
            return [
				'status'  => 'error',
				'message' => 'An unexpected error occurred. Please try again later.'
			];
        }

    }

    private function fetchEmployeeAttendanceRecords(string $cutoffStartDate, string $cutoffEndDate): ActionResult|array
    {
        $columns = [
        ];

        $filterCriteria = [
            [
                'column'   => 'work_schedule.employee_id',
                'operator' => '=',
                'value'    => $employeeId
            ],
            [
                'column'   => 'attendance.date',
                'operator' => '>=',
                'value'    => $cutoffStartDate
            ],
            [
                'column'   => 'attendance.date',
                'operator' => '<=',
                'value'    =>  $cutoffEndDate
            ]
        ];

        $actionResult = $this->attendanceRepository->fetchAllAttendance($columns, $filterCriteria);

        if ($actionResult === ActionResult::FAILURE) {
            return ActionResult::FAILURE;
        }

        return $actionResult['result_set'];
    }


<?php

    public function generatePayslips(PayrollGroup $payrollGroup, string $cutoffStartDate, string $cutoffEndDate): ?array
    {
        $employees = $this->fetchEmployees($payrollGroup->getId());

        if ($employees === ActionResult::FAILURE) {
            return [
				'status'  => 'error',
				'message' => 'An unexpected error occurred. Please try again later.'
			];
        }

        if (empty($employees)) {
            return null;
        }

        foreach ($employees as $employee) {
            $this->calculate($employee, $cutoffStartDate, $cutoffEndDate);
        }
    }

    private function fetchEmployees(int $payrollGroupId): ActionResult|array
    {
        $columns = [
            'id'           ,
            'job_title_id' ,
            'department_id',
            'annual_salary',
            'hourly_rate'
        ];

        $filterCriteria = [
			[
				'column'   => 'employee.access_role',
				'operator' => '!=',
				'value'    => "'Admin'"
			],
			[
				'column'   => 'employee.payroll_group_id',
				'operator' => '=',
				'value'    => $payrollGroupId
			]
        ];

        $actionResult = $this->employeeRepository->fetchAllEmployees($columns, $filterCriteria);

        if ($actionResult === ActionResult::FAILURE) {
            return ActionResult::FAILURE;
        }

        return $actionResult['result_set'];
    }

    private function calculate(array $employee, string $cutoffStartDate, string $cutoffEndDate): array
    {
        $cutoffStartDate = new DateTime($cutoffStartDate);
        $cutoffEndDate   = new DateTime($cutoffEndDate  );

        $formattedCutoffStartDate = $cutoffStartDate->format('Y-m-d');
        $formattedCutoffEndDate   = $cutoffEndDate  ->format('Y-m-d');

        $employeeId    = $employee['id'            ];
        $jobTitleId    = $employee['job_title_id'  ];
        $departmentId  = $employee['department_id' ];
        $annualySalary = $employee['annualy_salary'];
        $hourlyRate    = $employee['hourly_rate'   ];

        $employeeWorkSchedules = $this->workScheduleRepository->getEmployeeWorkSchedules(
            $employeeId,
            $formattedCutoffStartDate,
            $formattedCutoffEndDate
        );

        if ($employeeWorkSchedules === ActionResult::FAILURE) {
            return [
				'status'  => 'error',
				'message' => 'An unexpected error occurred. Please try again later.'
			];
        }

        $employeeAttendanceRecords = $this->fetchEmployeeAttendanceRecords(
            $employeeId,
            $formattedCutoffStartDate,
            $formattedCutoffEndDate
        );

        if ($employeeAttendanceRecords === ActionResult::FAILURE) {
            return [
				'status'  => 'error',
				'message' => 'An unexpected error occurred. Please try again later.'
			];
        }

        if ( ! $employeeAttendanceRecords) {

        }
    }

    private function fetchEmployeeAttendanceRecords(string $cutoffStartDate, string $cutoffEndDate): ActionResult|array
    {
        $columns = [
        ];

        $filterCriteria = [
            [
                'column'   => 'work_schedule.employee_id',
                'operator' => '=',
                'value'    => $employeeId
            ],
            [
                'column'   => 'attendance.date',
                'operator' => '>=',
                'value'    => $cutoffStartDate
            ],
            [
                'column'   => 'attendance.date',
                'operator' => '<=',
                'value'    =>  $cutoffEndDate
            ]
        ];

        $actionResult = $this->attendanceRepository->fetchAllAttendance($columns, $filterCriteria);

        if ($actionResult === ActionResult::FAILURE) {
            return ActionResult::FAILURE;
        }

        return $actionResult['result_set'];
    }

    private function getWorkScheduleAttendanceRecords(): array
    {

        foreach ($employeeWorkSchedules as $dateOfSchedule => $workSchedules) {
            foreach ($workSchedules as $workSchedule) {
                $workScheduleAttendanceRecords = [];

                foreach ($employeeAttendanceRecords as $attendanceRecord) {
                    if ($attendanceRecord['date'] === $dateOfSchedule && $attendanceRecord['work_schedule_id'] === $workSchedule['id']) {
                        $workScheduleAttendanceRecords[] = $attendanceRecord;
                    }
                }

                if ( ! empty($workScheduleAttendanceRecords)) {
                    [$dateOfSchedule][] = [
                        'work_schedule'      => $workSchedule,
                        'attendance_records' => $workScheduleAttendanceRecords
                    ];
                } else {
                    [$dateOfSchedule][] = [
                        'work_schedule'      => $workSchedule,
                        'attendance_records' => []
                    ];
                }
            }
        }
    }


                                    usort($defaultBreaks, function ($a, $b) {
                                        $startTimeA = new DateTime($a['start_time']);
                                        $startTimeB = new DateTime($b['start_time']);
                                        return $startTimeA <=> $startTimeB;
                                    });





<?php

$employeeBreaks = [
    [
        'id' => 47,
        'break_schedule_id' => 1,
        'start_time' => '2024-11-26 23:00:00',
        'end_time' => '2024-11-27 00:00:00',
        'break_duration_in_minutes' => 60,
        'created_at' => '2024-11-26 23:00:00',
        'work_schedule_id' => 1,
        'break_type_id' => 1,
        'break_schedule_start_time' => '2024-11-26 23:00:00',
        'is_flexible' => 0,
        'break_schedule_earliest_start_time' => null,
        'break_schedule_latest_end_time' => null,
        'employee_id' => 6,
        'break_type_duration_in_minutes' => 60,
        'break_type_is_paid' => 0,
    ],
    [
        'id' => 49,
        'break_schedule_id' => 15,
        'start_time' => '2024-11-27 02:00:00',
        'end_time' => '2024-11-27 02:05:00',
        'break_duration_in_minutes' => 60,
        'created_at' => '2024-11-27 02:00:00',
        'work_schedule_id' => 1,
        'break_type_id' => 1,
        'break_schedule_start_time' => null,
        'is_flexible' => 1,
        'break_schedule_earliest_start_time' => '2024-11-26 23:30:00',
        'break_schedule_latest_end_time' => '2024-11-27 03:00:00',
        'employee_id' => 6,
        'break_type_duration_in_minutes' => 60,
        'break_type_is_paid' => 0,
    ],
    [
        'id' => 50,
        'break_schedule_id' => 15,
        'start_time' => '2024-11-27 02:05:00',
        'end_time' => '2024-11-27 02:10:00',
        'break_duration_in_minutes' => 5,
        'created_at' => '2024-11-27 02:00:00',
        'work_schedule_id' => 1,
        'break_type_id' => 1,
        'break_schedule_start_time' => null,
        'is_flexible' => 1,
        'break_schedule_earliest_start_time' => '2024-11-26 23:30:00',
        'break_schedule_latest_end_time' => '2024-11-27 03:00:00',
        'employee_id' => 6,
        'break_type_duration_in_minutes' => 60,
        'break_type_is_paid' => 0,
    ],
    [
        'id' => 48,
        'break_schedule_id' => 14,
        'start_time' => '2024-11-27 01:00:00',
        'end_time' => '2024-11-27 01:30:00',
        'break_duration_in_minutes' => 60,
        'created_at' => '2024-11-27 01:00:00',
        'work_schedule_id' => 1,
        'break_type_id' => 1,
        'break_schedule_start_time' => '2024-11-27 01:00:00',
        'is_flexible' => 0,
        'break_schedule_earliest_start_time' => null,
        'break_schedule_latest_end_time' => null,
        'employee_id' => 6,
        'break_type_duration_in_minutes' => 60,
        'break_type_is_paid' => 0,
    ],
    [
        'id' => 51,
        'break_schedule_id' => 14,
        'start_time' => '2024-11-27 01:35:00',
        'end_time' => '2024-11-27 01:55:00',
        'break_duration_in_minutes' => 60,
        'created_at' => '2024-11-27 01:00:00',
        'work_schedule_id' => 1,
        'break_type_id' => 1,
        'break_schedule_start_time' => '2024-11-27 01:00:00',
        'is_flexible' => 0,
        'break_schedule_earliest_start_time' => null,
        'break_schedule_latest_end_time' => null,
        'employee_id' => 6,
        'break_type_duration_in_minutes' => 60,
        'break_type_is_paid' => 0,
    ],
    [
        'id' => 52,
        'break_schedule_id' => 16,
        'start_time' => null,
        'end_time' => null,
        'break_duration_in_minutes' => 0,
        'created_at' => '2024-11-27 01:00:00',
        'work_schedule_id' => 1,
        'break_type_id' => 1,
        'break_schedule_start_time' => '2024-11-27 01:00:00',
        'is_flexible' => 0,
        'break_schedule_earliest_start_time' => null,
        'break_schedule_latest_end_time' => null,
        'employee_id' => 6,
        'break_type_duration_in_minutes' => 60,
        'break_type_is_paid' => 0,
    ]
];

$groupedBreaks = [];
foreach ($employeeBreaks as $break) {
    $breakScheduleId = $break['break_schedule_id'];
    if ( ! isset($groupedBreaks[$breakScheduleId])) {
        $groupedBreaks[$breakScheduleId] = [];
    }
    $groupedBreaks[$breakScheduleId][] = $break;
}

$mergedBreaks = [];
foreach ($groupedBreaks as $breakScheduleId => $breaks) {
    $isFlexible = $breaks[0]['is_flexible'];
    $breakScheduleStartTime = $breaks[0]['break_schedule_start_time'];
    $breakTypeDurationInMinutes = $breaks[0]['break_type_duration_in_minutes'];

    if ($breaks[0]['start_time'] !== null && $breaks[0]['end_time'] !== null) {
        $firstStartTime = new DateTime($breaks[0]['start_time']);
        $lastEndTime = new DateTime($breaks[0]['end_time']);

        foreach ($breaks as $break) {
            if ($break['end_time'] !== null) {
                $currentEndTime = new DateTime($break['end_time']);

                if ($currentEndTime > $lastEndTime) {
                    $lastEndTime = $currentEndTime;
                }
            }
        }

        if ( ! $isFlexible && $breakScheduleStartTime) {
            $firstStartTime = new DateTime($breakScheduleStartTime);
        }

        $expectedEndTime = clone $firstStartTime;
        $expectedEndTime->add(new DateInterval("PT{$breakTypeDurationInMinutes}M"));

        if ($lastEndTime < $expectedEndTime) {
            $lastEndTime = $expectedEndTime;
        }

        $mergedBreak = $breaks[0];
        $mergedBreak['start_time'] = $firstStartTime->format('Y-m-d H:i:s');
        $mergedBreak['end_time'] = $lastEndTime->format('Y-m-d H:i:s');
        $mergedBreaks[] = $mergedBreak;
    } else {
        $mergedBreaks[] = $breaks[0];
    }
}

echo "Merged Breaks:\n";
print_r($mergedBreaks);


ORDER BY
                CASE
                    WHEN break_schedule.start_time IS NULL THEN break_schedule.earliest_start_time
                    ELSE break_schedule.start_time
                END ASC,
                break_schedule.earliest_start_time ASC,
                employee_break.start_time ASC


                                            if ( ! $break['break_type_is_paid']) {
                                                $interval = (new DateTime($break['end_time']))->diff(new DateTime($break['start_time']));
                                                $totalUnpaidBreakInMinutes += ($interval->h * 60) + $interval->i;
                                            }



$breakSchedules = $breakScheduleRepository->fetchOrderedBreakSchedules($workSchedule['id']);

                                    if ($breakSchedules === ActionResult::FAILURE) {
                                        return [
                                            'status' => 'error',
                                            'message' => 'An unexpected error occurred. Please try again later.'
                                        ];
                                    }

                                    if ( ! empty($breakSchedules)) {

                                    }

                                if (($datesMarkedAsLeave[$date]['is_leave'] && $datesMarkedAsLeave[$date]['is_paid']) || ( ! empty($datesMarkedAsHoliday[$date]))) {
                                    $startMinutes = (int) $workScheduleStartTime->format('i');
                                    $cloneWorkScheduleStartTime = clone $workScheduleStartTime;
                                    if ($startMinutes > 0) {
                                        $remainingMinutes = 60 - $startMinutes;
                                        $hour = (int) $workScheduleStartTime->format('H');
                                        $date = $workScheduleStartTime->format('Y-m-d');
                                        $isNightShift = ($hour >= 22 || $hour < 6);

                                        $dayOfWeek = (new DateTime($date))->format('l');
                                        $dayType = $dayOfWeek === 'Sunday' ? 'rest_day' : 'regular_day';

                                        $isHoliday = ! empty($datesMarkedAsHoliday[$date]);
                                        $holidayType = 'non_holiday';

                                        if ($isHoliday) {
                                            if (count($datesMarkedAsHoliday[$date]) > 1) {
                                                $holidayType = 'double_holiday';
                                            } elseif ($datesMarkedAsHoliday[$date]['is_paid']) {
                                                $holidayType = 'regular_holiday';
                                            }
                                        }

                                        if ($isNightShift) {
                                            $hourSummary1[$dayType][$holidayType]['night_differential'] += $remainingMinutes / 60;
                                        } else {
                                            $hourSummary1[$dayType][$holidayType]['regular_hours'] += $remainingMinutes / 60;
                                        }

                                        $cloneWorkScheduleStartTime->modify('+' . $remainingMinutes . ' minutes');
                                    }

                                    $endMinutes = (int) $workScheduleEndTime->format('i');
                                    $roundedWorkScheduleEndTime = clone $workScheduleEndTime;
                                    $roundedWorkScheduleEndTime->modify('-' . $endMinutes . ' minutes');

                                    $dateInterval = new DateInterval('PT1H');
                                    $datePeriod = new DatePeriod($cloneWorkScheduleStartTime, $dateInterval, $roundedWorkScheduleEndTime);

                                    foreach ($datePeriod as $currentTime) {
                                        $currentDate = $currentTime->format('Y-m-d');
                                        $hour = (int) $currentTime->format('H');
                                        $isNightShift = ($hour >= 22 || $hour < 6);

                                        $dayOfWeek = (new DateTime($currentDate))->format('l');
                                        $dayType = $dayOfWeek === 'Sunday' ? 'rest_day' : 'regular_day';

                                        $isHoliday = ! empty($datesMarkedAsHoliday[$currentDate]);
                                        $holidayType = 'non_holiday';

                                        if ($isHoliday) {
                                            if (count($datesMarkedAsHoliday[$currentDate]) > 1) {
                                                $holidayType = 'double_holiday';
                                            } elseif ($datesMarkedAsHoliday[$currentDate]['is_paid']) {
                                                $holidayType = 'regular_holiday';
                                            }
                                        }

                                        if ($isNightShift) {
                                            $hourSummary1[$dayType][$holidayType]['night_differential']++;
                                        } else {
                                            $hourSummary1[$dayType][$holidayType]['regular_hours']++;
                                        }
                                    }

                                    if ($endMinutes > 0) {
                                        $date = $workScheduleEndTime->format('Y-m-d');

                                        $hour = (int) $workScheduleEndTime->format('H');
                                        $isNightShift = ($hour >= 22 || $hour < 6);

                                        $dayOfWeek = (new DateTime($date))->format('l');
                                        $dayType = $dayOfWeek === 'Sunday' ? 'rest_day' : 'regular_day';

                                        $isHoliday = !empty($datesMarkedAsHoliday[$date]);
                                        $holidayType = 'non_holiday';

                                        if ($isHoliday) {
                                            if (count($datesMarkedAsHoliday[$date]) > 1) {
                                                $holidayType = 'double_holiday';
                                            } elseif ($datesMarkedAsHoliday[$date]['is_paid']) {
                                                $holidayType = 'regular_holiday';
                                            }
                                        }

                                        if ($isNightShift) {
                                            $hourSummary1[$dayType][$holidayType]['night_differential'] += $endMinutes / 60;
                                        } else {
                                            $hourSummary1[$dayType][$holidayType]['regular_hours'] += $endMinutes / 60;
                                        }
                                    }






                                }



} else {
                $startTime = new DateTime($lastBreakRecord['start_time']);
                $endTime = new DateTime($currentDateTime->format('Y-m-d H:i:s'));
                $breakTypeDurationInMinutes = $lastBreakRecord['break_type_duration_in_minutes'];

                if ( ! $lastBreakRecord['is_flexible']) {
                    $scheduleStartTime = new DateTime($lastBreakRecord['break_schedule_start_time']);

                    $scheduleEndTime = clone $scheduleStartTime;
                    $scheduleEndTime->add(new DateInterval("PT{$breakTypeDurationInMinutes}M"));

                    $breakDate = $startTime->format('Y-m-d');
                    $scheduleStartTime = new DateTime($breakDate . ' ' . $scheduleStartTime->format('H:i:s'));
                    $scheduleEndTime   = new DateTime($breakDate . ' ' . $scheduleEndTime  ->format('H:i:s'));

                    if ($scheduleEndTime->format('H:i:s') < $scheduleStartTime->format('H:i:s')) {
                        $scheduleEndTime->modify('+1 day');
                    }

                    echo $scheduleStartTime->format('Y-m-d H:i:s') . '<br>';
                    echo $scheduleEndTime->format('Y-m-d H:i:s') . '<br>';
                    $startTime = $scheduleStartTime;
                    if ($endTime < $scheduleEndTime) {
                        $endTime = $scheduleEndTime;
                    }
                } else {
                    $expectedEndTime = clone $startTime;
                    $expectedEndTime->add(new DateInterval("PT{$breakTypeDurationInMinutes}M"));

                    if ($endTime < $expectedEndTime) {
                        $endTime = $expectedEndTime;
                    }
                }

                $interval = $startTime->diff($endTime);
                $breakDurationInMinutes = $interval->h * 60 + $interval->i;

                $employeeBreak = new EmployeeBreak(
                    id                    : $lastBreakRecord['id'                 ],
                    breakScheduleId       : $lastBreakRecord['break_schedule_id'  ],
                    startTime             : $lastBreakRecord['start_time'         ],
                    endTime               : $currentDateTime->format('Y-m-d H:i:s'),
                    breakDurationInMinutes: $breakDurationInMinutes                ,
                    createdAt             : $lastBreakRecord['created_at']
                );

                $result = $this->employeeBreakRepository->breakOut($employeeBreak);

                if ($result === ActionResult::FAILURE) {
                    return [
                        'status'  => 'error7',
                        'message' => 'An unexpected error occurred. Please try again later.',
                    ];
                }
            }
        }









if ($employeeBreak['break_duration_in_minutes'] > $breakSchedule['break_type_duration_in_minutes']) {
                                    if ( ! $breakSchedule['break_type_is_paid']) {
                                        $unpaidBreakDurationInMinutes += $employeeBreak['break_duration_in_minutes'];
                                    } else {
                                        $paidBreakDurationInMinutes += $breakSchedule['break_type_duration_in_minutes'];
                                        $unpaidBreakDurationInMinutes += ($employeeBreak['break_duration_in_minutes'] - $breakSchedule['break_type_duration_in_minutes']);
                                    }
                                } else {
                                    if ( ! $breakSchedule['break_type_is_paid']) {
                                        $unpaidBreakDurationInMinutes += $employeeBreak['break_duration_in_minutes'];
                                    } else {
                                        $paidBreakDurationInMinutes += $employeeBreak['break_duration_in_minutes'];
                                    }
                                }

$breakStartTime = new DateTime($employeeBreak['start_time']);
                                $checkOutTime = clone $currentDateTime;

                                $breakScheduledEndTime = clone $breakStartTime;
                                $breakScheduledEndTime->modify("+{$breakSchedule['break_type_duration_in_minutes']} minutes");

                                if ($breakScheduledEndTime->format('H:i:s') < $breakStartTime->format('H:i:s')) {
                                    $breakScheduledEndTime->modify('+1 day');
                                }

                                $actualEndTime = ($checkOutTime < $breakScheduledEndTime) ? $checkOutTime : $breakScheduledEndTime;

                                $actualBreakDurationInMinutes = $breakStartTime->diff($actualEndTime);
                                $actualBreakDurationInMinutes = $actualBreakDurationInMinutes->h * 60 + $actualBreakDurationInMinutes->i;

                                if ($breakSchedule['break_type_is_paid']) {
                                    $paidBreakDurationInMinutes += $actualBreakDurationInMinutes;
                                } else {
                                    $unpaidBreakDurationInMinutes += $actualBreakDurationInMinutes;
                                }


    private function getCurrentWorkSchedule(array $workSchedules, string $currentTime): array
    {
        $currentWorkSchedule = [];
        $nextWorkSchedule    = [];

        $currentTime = (new DateTime($currentTime))->format('H:i:s');

        foreach ($workSchedules as $date => $schedules) {
            foreach ($schedules as $schedule) {
                $startTime = (new DateTime($schedule['start_time']))->format('H:i:s');
                $endTime   = (new DateTime($schedule['end_time'  ]))->format('H:i:s');

                if ($endTime < $startTime) {
                    if ($currentTime >= $startTime || $currentTime <= $endTime) {
                        $currentWorkSchedule = $schedule;
                        break 2;
                    }
                } else {
                    if ($currentTime >= $startTime && $currentTime <= $endTime) {
                        $currentWorkSchedule = $schedule;
                        break 2;
                    }
                }

                if (empty($nextWorkSchedule) && $currentTime < $startTime) {
                    $nextWorkSchedule = $schedule;
                }
            }
        }

        if (empty($currentWorkSchedule) && ! empty($nextWorkSchedule)) {
            $currentWorkSchedule = $nextWorkSchedule;
        }

        return $currentWorkSchedule;
    }

<?php

enum WorkScheduleEditOption: string
{
    case EDIT_THIS_ONLY     = 'Edit this schedule only'                 ;
    case EDIT_ALL_FUTURE    = 'Edit all future schedules in this series';
    case EDIT_ALL_SCHEDULES = 'All schedules in this series'            ;
}

<?php

require 'vendor/autoload.php';

use RRule\RRule;

class RecurrenceExtractor
{
    public function getRecurrenceDatesInRange(string $recurrencePattern, string $startDate, string $endDate): array
    {
        $rules = $this->parseRecurrencePattern($recurrencePattern);
        if (!$rules) {
            throw new InvalidArgumentException("Invalid recurrence pattern.");
        }

        $rule = new RRule($rules);
        $dates = [];

        foreach ($rule as $occurrence) {
            $date = $occurrence->format('Y-m-d');
            if ($date > $endDate) {
                break;
            }
            if ($date >= $startDate) {
                $dates[] = $date;
            }
        }
        return $dates;
    }

    private function parseRecurrencePattern(string $pattern): ?array
    {
        $parts = explode(';', $pattern);
        $rules = [];
        foreach ($parts as $part) {
            $pair = explode('=', $part);
            if (count($pair) == 2) {
                $rules[$pair[0]] = $pair[1];
            }
        }

        return $rules;
    }
}

// Example Work Schedules (mock data with recurrence rules)
$workSchedulesFromDB = [
    [
        'id' => 1,
        'start_time' => '09:00:00',
        'end_time' => '12:00:00',
        'is_flextime' => false,
        'flextime_start_time' => null,
        'flextime_end_time' => null,
        'recurrence_rule' => "FREQ=WEEKLY;INTERVAL=1;DTSTART=2024-11-04;BYDAY=MO,TU,WE,TH,FR,SA,SU;"
    ],
    [
        'id' => 2,
        'start_time' => '12:00:00',
        'end_time' => '15:00:00',
        'is_flextime' => false,
        'flextime_start_time' => null,
        'flextime_end_time' => null,
        'recurrence_rule' => "FREQ=WEEKLY;INTERVAL=1;DTSTART=2024-11-04;BYDAY=TU,WE;"
    ],
    [
        'id' => 3,
        'start_time' => '15:00:00',
        'end_time' => '18:00:00',
        'is_flextime' => false,
        'flextime_start_time' => null,
        'flextime_end_time' => null,
        'recurrence_rule' => "FREQ=WEEKLY;INTERVAL=1;DTSTART=2024-11-04;BYDAY=MO,WE;"
    ],
    [
        'id' => 4,
        'start_time' => '18:00:00',
        'end_time' => '21:00:00',
        'is_flextime' => false,
        'flextime_start_time' => null,
        'flextime_end_time' => null,
        'recurrence_rule' => "FREQ=WEEKLY;INTERVAL=1;DTSTART=2024-11-04;BYDAY=TU,FR;"
    ]
];

// Define the date range to extract schedules
$startDate = '2024-11-13';
$endDate = '2024-11-15';

// Initialize the recurrence extractor
$recurrenceExtractor = new RecurrenceExtractor();

$workSchedules = [];

// Initialize all dates in the range as empty arrays (or null, as per your requirement)
$start = new DateTime($startDate);
$end = (new DateTime($endDate))->modify('+1 day');

$interval = new DateInterval('P1D');
$dateRange = new DatePeriod($start, $interval, $end);

foreach ($dateRange as $date) {
    $workSchedules[$date->format('Y-m-d')] = []; // Initialize with an empty array or null
}
// Output the work schedules grouped by date inside the array
echo '<pre>';
print_r($workSchedules);
echo '</pre>';
// Loop through each work schedule and extract the recurrence dates
foreach ($workSchedulesFromDB as $workSchedule) {
    $recurrenceRule = $workSchedule['recurrence_rule'];
    $recurrenceDates = $recurrenceExtractor->getRecurrenceDatesInRange($recurrenceRule, $startDate, $endDate);

    foreach ($recurrenceDates as $recurrenceDate) {
        // Populate the array with the schedules for the corresponding date
        $workSchedules[$recurrenceDate][] = $workSchedule;
    }
}

// Output the work schedules grouped by date inside the array
echo '<pre>';
print_r($workSchedules);
echo '</pre>';








/*
<?php

require 'vendor/autoload.php';

use RRule\RRule;

// Set the recurrence rule data for weekly recurrence on Friday (no need for specifying first, second, or last)
$weeklyOnFridayRule = new RRule([
    'FREQ' => 'WEEKLY',        // Weekly recurrence
    'INTERVAL' => 1,           // Every 1 week
    'DTSTART' => '2024-11-02', // Start date (Let's say this is November 1st, 2024, which is a Friday)
    'BYDAY' => ['FR']          // Occurs every Friday
]);

// Print occurrences
echo "Weekly Recurrence (Every Friday):\n";
foreach ($weeklyOnFridayRule as $occurrence) {
    echo $occurrence->format('D d M Y') . ", ";
}
echo "\n";

?>

    public function getRecurrenceDates(string $recurrencePattern, string $startDate, string $endDate): array
    {
        $rules = $this->parseRecurrencePattern($recurrencePattern);


        $rules["DTSTART"] = $startDate;
        $rule = new RRule($rules);

        $dates = [];

        foreach ($rule as $occurrence) {
            $date = $occurrence->format('Y-m-d');

            if ($date > $endDate) {
                return $dates;
            }

            $dates[] = $date;
        }

        return $dates;
    }

    public function getRecurrenceDates(string $recurrenceRule, string $startDate, string $endDate): array
    {
        $parsedRecurrenceRule = $this->parseRecurrenceRule($recurrenceRule);

        $recurrence = new RRule($parsedRecurrenceRule);

        $dates = [];

        foreach ($recurrence as $occurence) {
            $date = $occurence->format("Y-m-d");

            if ($date > $endDate) {
                return $dates;
            }

            $dates[] = $date;
        }

        return $dates;
    }

    public function getRecurrenceDates(string $recurrenceRule, string $startDate, string $endDate): array
    {
        $parsedRecurrenceRule = $this->parseRecurrenceRule($recurrenceRule);

        $recurrence = new RRule($parsedRecurrenceRule);

        $dates = [];

        foreach ($recurrence as $occurence) {
            $date = $occurence->format("Y-m-d");

            if ($date > $endDate) {
                return $dates;
            }

            $dates[] = $date;
        }

        return $dates;
    }

    private function parseRecurrenceRule(string $rule): array
    {
        $parts = explode(";", $rule);

        $parsedRule = [];

        foreach ($parts as $part) {
            [$key, $value] = explode("=", $part, 2);

            $parsedRule[$key] = $value;
        }

        return $parsedRule;
    }
*/

/*
require_once __DIR__ . '/../includes/Helper.php'            ;
require_once __DIR__ . '/../includes/enums/ActionResult.php';
require_once __DIR__ . '/../includes/enums/ErrorCode.php'   ;

class AttendanceDao
{
    private readonly PDO $pdo;

    public function __construct(PDO $pdo)
    {
        $this->pdo = $pdo;
    }

    public function create(Attendance $attendance): ActionResult
    {
        $query = "
            INSERT INTO attendance (
                employee_id         ,
                date                ,
                shift_type          ,
                check_in_time       ,
                check_out_time      ,
                break_start_time    ,
                break_end_time      ,
                is_overtime_approved,
                attendance_status   ,
                remarks
            )
            VALUES (
                :employee_id         ,
                :date                ,
                :shift_type          ,
                :check_in_time       ,
                :check_out_time      ,
                :break_start_time    ,
                :break_end_time      ,
                :is_overtime_approved,
                :attendance_status   ,
                :remarks
            )
        ";

        try {
            $this->pdo->beginTransaction();

            $statement = $this->pdo->prepare($query);

            $statement->bindValue(":employee_id"         , $attendance->getEmployeeId()      , Helper::getPdoParameterType($attendance->getEmployeeId()      ));
            $statement->bindValue(":date"                , $attendance->getDate()            , Helper::getPdoParameterType($attendance->getDate()            ));
            $statement->bindValue(":shift_type"          , $attendance->getShiftType()       , Helper::getPdoParameterType($attendance->getShiftType()       ));
            $statement->bindValue(":check_in_time"       , $attendance->getCheckInTime()     , Helper::getPdoParameterType($attendance->getCheckInTime()     ));
            $statement->bindValue(":check_out_time"      , $attendance->getCheckOutTime()    , Helper::getPdoParameterType($attendance->getCheckOutTime()    ));
            $statement->bindValue(":break_start_time"    , $attendance->getBreakStartTime()  , Helper::getPdoParameterType($attendance->getBreakStartTime()  ));
            $statement->bindValue(":break_end_time"      , $attendance->getBreakEndTime()    , Helper::getPdoParameterType($attendance->getBreakEndTime()    ));
            $statement->bindValue(":is_overtime_approved", $attendance->isOvertimeApproved() , Helper::getPdoParameterType($attendance->isOvertimeApproved() ));
            $statement->bindValue(":attendance_status"   , $attendance->getAttendanceStatus(), Helper::getPdoParameterType($attendance->getAttendanceStatus()));
            $statement->bindValue(":remarks"             , $attendance->getRemarks()         , Helper::getPdoParameterType($attendance->getRemarks()         ));

            $statement->execute();

            $this->pdo->commit();

            return ActionResult::SUCCESS;

        } catch (PDOException $exception) {
            $this->pdo->rollBack();

            error_log("Database Error: An error occurred while creating the attendance record. " .
                      "Exception: {$exception->getMessage()}");

            return ActionResult::FAILURE;
        }
    }

    public function fetchAll(
        ?array $columns        = null,
        ?array $filterCriteria = null,
        ?array $sortCriteria   = null,
        ?int   $limit          = null,
        ?int   $offset         = null
    ): ActionResult|array {
        $tableColumns = [
            "id"                  => "attendance.id                  AS id",
            "employee_id"         => "attendance.employee_id         AS employee_id",
            "employee_code" => "",
            "employee_full_name" => "",
            "employee_department" => "",
            "employee_job_title" => "",
            "date"                => "attendance.date                AS date",
            "day_of_week"         => "DAYNAME(attendance.date)       AS day_of_week",
            "shift_type"          => "attendance.shift_type          AS shift_type",
            "check_in_time"       => "attendance.check_in_time       AS check_in_time",
            "check_out_time"      => "attendance.check_out_time      AS check_out_time",
            "break_start_time"    => "attendance.break_start_time    AS break_start_time",
            "break_end_time"      => "attendance.break_end_time      AS break_end_time",
            "is_overtime_approved"=> "attendance.is_overtime_approved AS is_overtime_approved",
            "attendance_status"   => "attendance.attendance_status   AS attendance_status",
            "remarks"             => "attendance.remarks             AS remarks",
            "created_at"          => "attendance.created_at          AS created_at",
            "updated_at"          => "attendance.updated_at          AS updated_at"
        ];

        $selectedColumns =
            empty($columns)
                ? $tableColumns
                : array_intersect_key(
                    $tableColumns,
                    array_flip($columns)
                );

        $queryParameters = [];

        $whereClauses = [];

        if ( ! empty($filterCriteria)) {
            foreach ($filterCriteria as $filterCriterion) {
                $column   = $filterCriterion["column"  ];
                $operator = $filterCriterion["operator"];

                switch ($operator) {
                    case "=":
                    case "LIKE":
                        $whereClauses   [] = "{$column} {$operator} ?";
                        $queryParameters[] = $filterCriterion["value"];
                        break;

                    case "BETWEEN":
                        $whereClauses   [] = "{$column} {$operator} ? AND ?";
                        $queryParameters[] = $filterCriterion["lower_bound"];
                        $queryParameters[] = $filterCriterion["upper_bound"];
                        break;

                    default:
                        // Do nothing
                }
            }
        }

        $orderByClauses = [];

        if (!empty($sortCriteria)) {
            foreach ($sortCriteria as $sortCriterion) {
                $column = $sortCriterion["column"];

                if (isset($sortCriterion["direction"])) {
                    $direction = $sortCriterion["direction"];
                    $orderByClauses[] = "{$column} {$direction}";

                } elseif (isset($sortCriterion["custom_order"])) {
                    $customOrder = $sortCriterion["custom_order"];
                    $caseExpressions = ["CASE {$column}"];

                    foreach ($customOrder as $priority => $value) {
                        $caseExpressions[] = "WHEN ? THEN {$priority}";
                        $queryParameters[] = $value;
                    }

                    $caseExpressions[] = "ELSE " . count($caseExpressions) . " END";
                    $orderByClauses[] = implode(" ", $caseExpressions);
                }
            }
        }

        $limitClause = "";
        if ($limit !== null) {
            $limitClause = " LIMIT ?";
            $queryParameters[] = $limit;
        }

        $offsetClause = "";
        if ($offset !== null) {
            $offsetClause = " OFFSET ?";
            $queryParameters[] = $offset;
        }

        $query = "
            SELECT SQL_CALC_FOUND_ROWS
                " . implode(", ", $selectedColumns) . "
            FROM
                attendance
            WHERE
            " . implode(" AND ", $whereClauses) . "
            " . (!empty($orderByClauses) ? "ORDER BY " . implode(", ", $orderByClauses) : "") . "
            {$limitClause}
            {$offsetClause}
        ";

        try {
            $statement = $this->pdo->prepare($query);

            foreach ($queryParameters as $index => $parameter) {
                $statement->bindValue($index + 1, $parameter, Helper::getPdoParameterType($parameter));
            }

            $statement->execute();

            $resultSet = [];
            while ($row = $statement->fetch(PDO::FETCH_ASSOC)) {
                $resultSet[] = $row;
            }

            $countStatement = $this->pdo->query("SELECT FOUND_ROWS()");
            $totalRowCount = $countStatement->fetchColumn();

            return [
                "result_set"      => $resultSet    ,
                "total_row_count" => $totalRowCount
            ];

        } catch (PDOException $exception) {
            error_log("Database Error: An error occurred while fetching the attendance records. " .
                      "Exception: {$exception->getMessage()}");

            return ActionResult::FAILURE;
        }
    }

    public function update(Attendance $attendance): ActionResult
    {
        $query = "
            UPDATE attendance
            SET
                employee_id          = :employee_id         ,
                date                 = :date                ,
                shift_type           = :shift_type          ,
                check_in_time        = :check_in_time       ,
                check_out_time       = :check_out_time      ,
                break_start_time     = :break_start_time    ,
                break_end_time       = :break_end_time      ,
                is_overtime_approved = :is_overtime_approved,
                attendance_status    = :attendance_status   ,
                remarks              = :remarks
            WHERE
                id = :attendance_id
        ";

        try {
            $this->pdo->beginTransaction();

            $statement = $this->pdo->prepare($query);

            $statement->bindValue(":employee_id"         , $attendance->getEmployeeId()      , Helper::getPdoParameterType($attendance->getEmployeeId()      ));
            $statement->bindValue(":date"                , $attendance->getDate()            , Helper::getPdoParameterType($attendance->getDate()            ));
            $statement->bindValue(":shift_type"          , $attendance->getShiftType()       , Helper::getPdoParameterType($attendance->getShiftType()       ));
            $statement->bindValue(":check_in_time"       , $attendance->getCheckInTime()     , Helper::getPdoParameterType($attendance->getCheckInTime()     ));
            $statement->bindValue(":check_out_time"      , $attendance->getCheckOutTime()    , Helper::getPdoParameterType($attendance->getCheckOutTime()    ));
            $statement->bindValue(":break_start_time"    , $attendance->getBreakStartTime()  , Helper::getPdoParameterType($attendance->getBreakStartTime()  ));
            $statement->bindValue(":break_end_time"      , $attendance->getBreakEndTime()    , Helper::getPdoParameterType($attendance->getBreakEndTime()    ));
            $statement->bindValue(":is_overtime_approved", $attendance->isOvertimeApproved() , Helper::getPdoParameterType($attendance->isOvertimeApproved() ));
            $statement->bindValue(":attendance_status"   , $attendance->getAttendanceStatus(), Helper::getPdoParameterType($attendance->getAttendanceStatus()));
            $statement->bindValue(":remarks"             , $attendance->getRemarks()         , Helper::getPdoParameterType($attendance->getRemarks()         ));
            $statement->bindValue(":attendance_id"       , $attendance->getId()              , Helper::getPdoParameterType($attendance->getId()              ));

            $statement->execute();

            $this->pdo->commit();

            return ActionResult::SUCCESS;

        } catch (PDOException $exception) {
            $this->pdo->rollBack();

            error_log("Database Error: An error occurred while updating the attendance record. " .
                      "Exception: {$exception->getMessage()}");

            return ActionResult::FAILURE;
        }
    }
}
*/


<?php
try {
    $pdo = new PDO('mysql:host=localhost;dbname=payroll', 'root', '');
    $pdo->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);

    $employee_id = null;  // Example employee_id (can be null)
    $job_title_id = null;  // Example job_title_id (can be null)
    $department_id = null;   // Example department_id (can be null)

    $query = "
    SELECT id
    FROM test
    WHERE
        (employee_id = :employee_id AND job_title_id = :job_title_id AND department_id = :department_id)
    OR
        (employee_id IS NULL AND job_title_id = :job_title_id AND department_id = :department_id)
    OR
        (employee_id IS NULL AND job_title_id IS NULL AND department_id = :department_id)
    OR
        (employee_id IS NULL AND job_title_id IS NULL AND department_id IS NULL)
    ORDER BY
        CASE
            WHEN employee_id = :employee_id AND job_title_id = :job_title_id AND department_id = :department_id THEN 1
            WHEN employee_id IS NULL AND job_title_id = :job_title_id AND department_id = :department_id THEN 2
            WHEN employee_id IS NULL AND job_title_id IS NULL AND department_id = :department_id THEN 3
            WHEN employee_id IS NULL AND job_title_id IS NULL AND department_id IS NULL THEN 4
            ELSE 5
        END
    LIMIT 1
    ";

        $statement = $pdo->prepare($query);

        // Binding values using Helper::getPdoParameterType() for correct parameter types
        $statement->bindValue(":employee_id"   , $employee_id   , PDO::PARAM_INT);
        $statement->bindValue(":job_title_id"  , $job_title_id  , PDO::PARAM_INT);
        $statement->bindValue(":department_id" , $department_id , PDO::PARAM_INT);

        $statement->execute();

        $id = $statement->fetchColumn();

echo $id;
} catch (PDOException $e) {
    echo "Error: " . $e->getMessage();
}

/*

<?php

$currentTime = '04:35:00';

$workSchedules = [
    '2024-11-24' => [
        [
            'start_time' => '08:00:00',
            'end_time'   => '17:00:00',
        ],
        [
            'start_time' => '18:00:00',
            'end_time'   => '19:00:00',
        ],
        [
            'start_time' => '20:00:00',
            'end_time'   => '03:00:00',
        ],
    ]
];

$currentWorkSchedule = [];
$nextWorkSchedule = [];

foreach ($workSchedules as $date => $schedules) {
    foreach ($schedules as $schedule) {
        $startTime = $schedule['start_time'];
        $endTime   = $schedule['end_time'  ];

        if ($endTime < $startTime) {
            if ($currentTime >= $startTime || $currentTime <= $endTime) {
                $currentWorkSchedule = $schedule;
                break 2;
            }
        } else {
            if ($currentTime >= $startTime && $currentTime <= $endTime) {
                $currentWorkSchedule = $schedule;
                break 2;
            }
        }

        if (empty($nextWorkSchedule) && $currentTime < $startTime) {
            $nextWorkSchedule = $schedule;
        }
    }
}

if (empty($currentWorkSchedule) && ! empty($nextWorkSchedule)) {
    $currentWorkSchedule = $nextWorkSchedule;
}

print_r($currentWorkSchedule);

*/

