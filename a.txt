        if ($result === ActionResult::SUCCESS) {
            return [
                'status' => 'success',
                'message' => 'Employee created successfully.',
            ];
        } elseif ($result === ActionResult::FAILURE) {
            return [
                'status' => 'error',
                'message' => 'Failed to create the employee.',
            ];
        } else {
            return [
                'status' => 'error',
                'message' => "Error occurred: Duplicate entry for key '{$result}'.",
            ];
        }

    public function changePassword(int $employeeId, string $currentPassword, string $newPassword): ActionResult
    {
        $getPasswordQuery = "
            SELECT
                password
            FROM
                employees
            WHERE
                id = :employee_id
        ";

        try {
            $statement = $this->pdo->prepare($getPasswordQuery);

            $statement->bindValue(":employee_id", $employeeId, Helper::getPdoParameterType($employeeId));

            $statement->execute();

            $employee = $statement->fetch(PDO::FETCH_ASSOC);

            if ( ! password_verify($currentPassword, $employee["password"])) {
                return ActionResult::PASSWORD_INCORRECT;
            }

            $hashedPassword = password_hash($newPassword, PASSWORD_BCRYPT);

            $this->pdo->beginTransaction();

            $changePasswordQuery = "
                UPDATE employees
                SET
                    password = :new_password
                WHERE
                    id = :employee_id
            ";

            $updateStatement = $this->pdo->prepare($changePasswordQuery);

            $updateStatement->bindValue(":new_password", $hashedPassword, Helper::getPdoParameterType($hashedPassword));
            $updateStatement->bindValue(":employee_id" , $employeeId    , Helper::getPdoParameterType($employeeId    ));

            $updateStatement->execute();

            $this->pdo->commit();

            return ActionResult::SUCCESS;

        } catch (PDOException $exception) {
            $this->pdo->rollBack();

            error_log("Database Error: An error occurred while changing the password. " .
                      "Exception: {$exception->getMessage()}");

            return ActionResult::FAILURE;
        }
    }

        if ($result === ActionResult::FAILURE) {
            return [
                'status'  => 'error',
                'message' => 'Failed to fetch the employee.'
            ];
        }

        if (empty($result['result_set'])) {
            return [
                'status'  => 'error',
                'message' => 'Employee not found.'
            ];
        }

        return [
            'status' => 'success',
            'id'     => $result['result_set'][0]['id']
        ];

<?php

require_once __DIR__ . "/../includes/Helper.php"            ;
require_once __DIR__ . "/../includes/enums/ActionResult.php";
require_once __DIR__ . "/../includes/enums/ErrorCode.php"   ;

class OvertimeRateAssignmentDao
{
    private readonly PDO $pdo;
    private readonly OvertimeRateDao $overtimeRateDao;

    public function __construct(PDO $pdo, OvertimeRateDao $overtimeRateDao)
    {
        $this->pdo = $pdo;
        $this->overtimeRateDao = $overtimeRateDao;
    }

    public function create(OvertimeRateAssignment $overtimeRateAssignment): ActionResult
    {
        $query = "
            INSERT INTO overtime_rate_assignments (
                department_id       ,
                job_title_id        ,
                employee_id         ,
                assignment_level
            ) VALUES (
                :department_id       ,
                :job_title_id        ,
                :employee_id         ,
                :assignment_level
            )
        ";

        try {
            $this->pdo->beginTransaction();

            $statement = $this->pdo->prepare($query);

            $statement->bindValue(':department_id'       , $overtimeRateAssignment->getDepartmentId()     , Helper::getPdoParameterType($overtimeRateAssignment->getDepartmentId()     ));
            $statement->bindValue(':job_title_id'        , $overtimeRateAssignment->getJobTitleId()       , Helper::getPdoParameterType($overtimeRateAssignment->getJobTitleId()       ));
            $statement->bindValue(':employee_id'         , $overtimeRateAssignment->getEmployeeId()       , Helper::getPdoParameterType($overtimeRateAssignment->getEmployeeId()       ));
            $statement->bindValue(':assignment_level'    , $overtimeRateAssignment->getAssignmentLevel()  , Helper::getPdoParameterType($overtimeRateAssignment->getAssignmentLevel()  ));

            $statement->execute();

            $this->pdo->commit();

            return ActionResult::SUCCESS;

        } catch (PDOException $exception) {
            $this->pdo->rollBack();

            error_log("Database Error: An error occurred while creating the overtime rate assignment. " .
                      "Exception: {$exception->getMessage()}");

            return ActionResult::FAILURE;
        }
    }

    private function hasExistingAssignment(OvertimeRateAssignment $overtimeRateAssignment): ActionResult|bool
    {
        $query = "
            SELECT
                id
            FROM
                overtime_rate_assignments
            WHERE
                (:department_id IS NULL OR department_id = :department_id)
            AND (:job_title_id  IS NULL OR job_title_id  = :job_title_id )
            AND (:employee_id   IS NULL OR employee_id   = :employee_id  )
            AND assignment_level = :assignment_level
            LIMIT 1
        ";

        try {
            $statement = $this->pdo->prepare($query);

            $statement->bindValue(':department_id'   , $overtimeRateAssignment->getDepartmentId()   , Helper::getPdoParameterType($overtimeRateAssignment->getDepartmentId()   ));
            $statement->bindValue(':job_title_id'    , $overtimeRateAssignment->getJobTitleId()     , Helper::getPdoParameterType($overtimeRateAssignment->getJobTitleId()     ));
            $statement->bindValue(':employee_id'     , $overtimeRateAssignment->getEmployeeId()     , Helper::getPdoParameterType($overtimeRateAssignment->getEmployeeId()     ));
            $statement->bindValue(':assignment_level', $overtimeRateAssignment->getAssignmentLevel(), Helper::getPdoParameterType($overtimeRateAssignment->getAssignmentLevel()));

            $statement->execute();

            return $statement->rowCount() > 0;

        } catch (PDOException $exception) {
            error_log("Database Error: An error occurred while checking for an existing assignment. " .
                      "Exception: {$exception->getMessage()}");

            return ActionResult::FAILURE;
        }
    }

    public function assign(OvertimeRateAssignment $overtimeRateAssignment, array $overtimeRates): ActionResult
    {
        try {
            $this->pdo->beginTransaction();

            $hasExistingAssignment = $this->hasExistingAssignment($overtimeRateAssignment);

            if ($hasExistingAssignment === ActionResult::FAILURE) {
                return ActionResult::FAILURE;
            }

            if ($hasExistingAssignment === false) {
                $insertOvertimeRateSetQuery = "INSERT INTO overtime_rate_sets () VALUES ()";
                $this->pdo->exec($insertOvertimeRateSetQuery);

                $overtimeRateSetId = $this->pdo->lastInsertId();

                foreach ($overtimeRates as $overtimeRate) {
                    $result = $this->overtimeRateDao->create($overtimeRate, $overtimeRateSetId);

                    if ($result === ActionResult::FAILURE) {
                        $this->pdo->rollBack();

                        return ActionResult::FAILURE;
                    }
                }

                $overtimeRateAssignment = new OvertimeRateAssignment(
                    null,
                    $overtimeRateAssignment->getDepartmentId(),
                    $overtimeRateAssignment->getJobTitleId(),
                    $overtimeRateAssignment->getEmployeeId(),
                    $overtimeRateAssignment->getAssignmentLevel()
                );

                $this->create($overtimeRateAssignment);

            } else {
                foreach ($overtimeRates as $overtimeRate) {
                    $result = $this->overtimeRateDao->update($overtimeRate);

                    if ($result === ActionResult::FAILURE) {
                        $this->pdo->rollBack();

                        return ActionResult::FAILURE;
                    }
                }
            }

            $this->pdo->commit();

            return ActionResult::SUCCESS;

        } catch (PDOException $exception) {
            $this->pdo->rollBack();

            error_log("Database Error: An error occurred while assigning the overtime rates. " .
                      "Exception: {$exception->getMessage()}");

            return ActionResult::FAILURE;
        }
    }
}

<?php
try {
    $pdo = new PDO('mysql:host=localhost;dbname=your_database', 'username', 'password');
    $pdo->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);

    $employee_id = 123;
    $job_title_id = 456;
    $department_id = 789;
    $assignment_level = 'Employee';

    $id = null;

    if ($assignment_level == 'Employee') {
        $sql = "SELECT id FROM overtime_rate_assignments WHERE employee_id = :employee_id";
        $stmt = $pdo->prepare($sql);
        $stmt->bindParam(':employee_id', $employee_id);
        $stmt->execute();
        $id = $stmt->fetchColumn();

        if ($id === false) {
            $sql = "SELECT id FROM overtime_rate_assignments WHERE job_title_id = :job_title_id";
            $stmt = $pdo->prepare($sql);
            $stmt->bindParam(':job_title_id', $job_title_id);
            $stmt->execute();
            $id = $stmt->fetchColumn();

            if ($id === false) {
                $sql = "SELECT id FROM overtime_rate_assignments WHERE department_id = :department_id";
                $stmt = $pdo->prepare($sql);
                $stmt->bindParam(':department_id', $department_id);
                $stmt->execute();
                $id = $stmt->fetchColumn();

                if ($id === false) {
                    $sql = "SELECT id FROM overtime_rate_assignments WHERE assignment_level = 'All' AND department_id IS NULL AND job_title_id IS NULL AND employee_id IS NULL";
                    $stmt = $pdo->prepare($sql);
                    $stmt->execute();
                    $id = $stmt->fetchColumn();
                }
            }
        }
    } elseif ($assignment_level == 'Job Title') {
        $sql = "SELECT id FROM overtime_rate_assignments WHERE job_title_id = :job_title_id";
        $stmt = $pdo->prepare($sql);
        $stmt->bindParam(':job_title_id', $job_title_id);
        $stmt->execute();
        $id = $stmt->fetchColumn();

        if ($id === false) {
            $sql = "SELECT id FROM overtime_rate_assignments WHERE department_id = :department_id";
            $stmt = $pdo->prepare($sql);
            $stmt->bindParam(':department_id', $department_id);
            $stmt->execute();
            $id = $stmt->fetchColumn();

            if ($id === false) {
                $sql = "SELECT id FROM overtime_rate_assignments WHERE assignment_level = 'All' AND department_id IS NULL AND job_title_id IS NULL AND employee_id IS NULL";
                $stmt = $pdo->prepare($sql);
                $stmt->execute();
                $id = $stmt->fetchColumn();
            }
        }
    } elseif ($assignment_level == 'Department') {
        $sql = "SELECT id FROM overtime_rate_assignments WHERE department_id = :department_id";
        $stmt = $pdo->prepare($sql);
        $stmt->bindParam(':department_id', $department_id);
        $stmt->execute();
        $id = $stmt->fetchColumn();

        if ($id === false) {
            $sql = "SELECT id FROM overtime_rate_assignments WHERE assignment_level = 'All' AND department_id IS NULL AND job_title_id IS NULL AND employee_id IS NULL";
            $stmt = $pdo->prepare($sql);
            $stmt->execute();
            $id = $stmt->fetchColumn();
        }
    } elseif ($assignment_level == 'All') {
        $sql = "SELECT id FROM overtime_rate_assignments WHERE assignment_level = 'All' AND department_id IS NULL AND job_title_id IS NULL AND employee_id IS NULL";
        $stmt = $pdo->prepare($sql);
        $stmt->execute();
        $id = $stmt->fetchColumn();
    }

    if ($id !== false) {
        echo "ID: " . $id;
    } else {
        echo "No ID found.";
    }

} catch (PDOException $e) {
    echo "Error: " . $e->getMessage();
}
?>

        foreach ($attendanceLogPreviousAndCurrentDay as $attendanceLog) {
            $checkInTime  = $attendanceLogPreviousAndCurrentDay['check_in_time' ];
            $checkOutTime = $attendanceLogPreviousAndCurrentDay['check_out_time'];

            foreach ($workSchedules as $workSchedule) {
                $workScheduleStartTime = $workSchedule['start_time'];
                $workScheduleEndTime   = $workSchedule['end_time'  ];

                if ($checkInTime !== null && $checkOutTime !== null) {
                    // Do nothing
                } elseif (($checkInTime  === null  &&
                           $checkOutTime === null) &&

                          ($currentTime <  $workScheduleStartTime ||
                          ($currentTime >= $workScheduleStartTime &&
                           $currentTime <= $workScheduleEndTime))) {
                    $currentSchedule = $workSchedule;
                } elseif (($checkInTime  !== null  &&
                           $checkOutTime === null) &&

                           ($currentTime >  $workScheduleEndTime   ||
                           ($currentTime >= $workScheduleStartTime &&
                            $currentTime <= $workScheduleEndTime))) {
                    $currentSchedule = $workSchedule;
                }

            }










<?php
require 'vendor/autoload.php';
use RRule\RSet;
use RRule\RRule;


class RecurrenceService
{
    private $exclusionDates = [];

    // This method adds a recurrence rule to the RSet
    public function addRecurrenceRuleToRSet(RSet $rset)
    {
        $rset->addRRule(array(
            'FREQ' => 'YEARLY',
            'COUNT' => 3,
            'BYDAY' => 'TU',
            'DTSTART' => date_create('1997-09-02 09:00')
        ));
    }

    // This method adds an exclusion date to the RSet
    public function addExclusionDateToRSet(RSet $rset, $date)
    {
        $rset->addExDate($date);
    }

    // This method returns all recurrence dates between the start and end dates, excluding any dates in the exclusion list
    public function getRecurrenceDates(string $recurrenceRule, string $startDate, string $endDate): array
    {
        try {
            $parsedRecurrenceRule = $this->parseRecurrenceRule($recurrenceRule);

            $recurrence = new RRule($parsedRecurrenceRule);

            $startDate = (new DateTime($startDate))->format("Y-m-d");
            $endDate   = (new DateTime($endDate))->format("Y-m-d");

            $dates = [];

            // Get exclusion dates from the set
            $exclusionDates = $this->getExclusionDates();

            foreach ($recurrence as $occurence) {
                $date = $occurence->format("Y-m-d");

                // Skip the date if it's in the exclusion list
                if (in_array($date, $exclusionDates)) {
                    continue;
                }

                // If the date is beyond the end date, return the dates up until then
                if ($date > $endDate) {
                    return $dates;
                }

                // If the date is within the valid range, add it to the list
                if ($date >= $startDate) {
                    $dates[] = $date;
                }
            }

            return $dates;

        } catch (InvalidArgumentException $exception) {
            error_log("Invalid Argument Error: " . $exception->getMessage());
            return [];

        } catch (Exception $exception) {
            error_log("General Error: " . $exception->getMessage());
            return [];
        }
    }

    // This method parses the recurrence rule string into an array of parameters
    private function parseRecurrenceRule(string $rule): array
    {
        try {
            $rule = rtrim($rule, ";");

            $parts = explode(";", $rule);

            $parsedRule = [];

            foreach ($parts as $part) {
                [$key, $value] = explode("=", $part, 2);
                $parsedRule[$key] = $value;
            }

            return $parsedRule;

        } catch (Exception $exception) {
            error_log("Parsing Error: An error occurred while parsing the recurrence rule. " . $exception->getMessage());
            return [];
        }
    }

    // This method returns the exclusion dates (for now, itâ€™s just a placeholder)
    private function getExclusionDates(): array
    {
        return $this->exclusionDates;
    }

    // This method allows adding exclusion dates to the class
    public function addExclusionDate(string $date)
    {
        $this->exclusionDates[] = $date;
    }
}

// Example usage:

$rset = new RSet();
$recurrenceService = new RecurrenceService();

// Add recurrence rule
$recurrenceService->addRecurrenceRuleToRSet($rset);

// Add exclusion date
$recurrenceService->addExclusionDate('1997-09-04'); // Add 1997-09-04 to exclusion list

// Add exclusion date to RSet
$recurrenceService->addExclusionDateToRSet($rset, '1997-09-04 09:00');

// Get recurrence dates
$recurrenceRule = "FREQ=YEARLY;COUNT=3;BYDAY=TU;DTSTART=1997-09-02T090000";
$startDate = '1997-09-01';
$endDate = '1997-09-10';

$recurrenceDates = $recurrenceService->getRecurrenceDates($recurrenceRule, $startDate, $endDate);

// Print the recurrence dates
foreach ($recurrenceDates as $occurrence) {
    echo $occurrence . "\n";
}















<?php

require 'vendor/autoload.php';

use RRule\RSet;

function getRecurrenceDates(string $recurrenceRule, string $startDate, string $endDate): array
{
    try {
        $rset = new RSet();
        $exdates = '';

        if (preg_match('/EXDATE=([^;]+)/', $recurrenceRule, $matches)) {
            $exdates = $matches[1];
            $recurrenceRule = str_replace("EXDATE={$exdates};", '', $recurrenceRule);
        }

        $parsedRule = parseRecurrenceRule($recurrenceRule);
        $rset->addRRule($parsedRule);

        if ($exdates) {
            $excludeDates = explode(",", $exdates);
            foreach ($excludeDates as $exDate) {
                $rset->addExDate($exDate);
            }
        }

        $startDate = (new DateTime($startDate))->format("Y-m-d");
        $endDate = (new DateTime($endDate))->format("Y-m-d");

        $dates = [];
        foreach ($rset as $date) {
            $dateFormatted = $date->format("Y-m-d");

            if ($dateFormatted > $endDate) {
                return $dates;
            }

            if ($dateFormatted >= $startDate && $dateFormatted <= $endDate) {
                $dates[] = $dateFormatted;
            }
        }

        return $dates;

    } catch (InvalidArgumentException $exception) {
        error_log("Invalid Argument Error: An error occurred while processing the recurrence rule. " .
                  "Exception: {$exception->getMessage()}");

        return [];

    } catch (Exception $exception) {
        error_log("General Error: An error occurred while processing the recurrence dates. " .
                  "Exception: {$exception->getMessage()}");

        return [];
    }
}

function parseRecurrenceRule(string $rule): array
{
    $rule = rtrim($rule, ";");
    $parts = explode(";", $rule);
    $parsedRule = [];

    foreach ($parts as $part) {
        [$key, $value] = explode("=", $part, 2);
        $parsedRule[$key] = $value;
    }

    return $parsedRule;
}

$recurrenceRule = "FREQ=WEEKLY;INTERVAL=1;DTSTART=2024-11-04;BYDAY=MO,WE;EXDATE=2024-11-04,2024-11-06;";
$startDate = "2024-11-01";
$endDate = "2024-11-30";

$dates = getRecurrenceDates($recurrenceRule, $startDate, $endDate);
echo '<pre>';
print_r($dates);
echo '<pre>';


<?php

    private function fetchEmployeeAllowances(int $employeeId): ActionResult|array
    {
        $columns = [
            'id'                      ,
            'allowance_id'            ,
            'allowance_is_taxable'    ,
            'allowance_frequency'     ,
            'allowance_status'        ,
            'allowance_effective_date',
            'allowance_end_date'      ,
            'amount'
        ];

        $filterCriteria = [
            [
                'column'   => 'employee_allowance.deleted_at',
                'operator' => 'IS NULL'
            ],
            [
                'column'   => 'employee_allowance.employee_id',
                'operator' => '='
                'value'    => $employeeId
            ],
            [
                'column'   => 'allowance.status'
                'operator' => '='
                'value'    => "'Active'"
            ]
        ];

        $employeeAllowances = $this->employeeAllowanceRepository->fetchAll($columns, $filterCriteria);

        if ($employeeAllowances === ActionResult::FAILURE) {
            return ActionResult::FAILURE;
        }

        return empty($employeeAllowances)
            ? []
            : $employeeAllowances['result_set'];
    }

    private function fetchEmployeeDeductions(int $employeeId): ActionResult|array
    {
        $columns = [
            'id'                      ,
            'deduction_id'            ,
            'deduction_is_pre_tax'    ,
            'deduction_frequency'     ,
            'deduction_status'        ,
            'deduction_effective_date',
            'deduction_end_date'      ,
            'amount_type'             ,
            'amount'                  ,
        ];

        $filterCriteria = [
            [
                'column'   => 'employee_deduction.deleted_at',
                'operator' => 'IS NULL'
            ],
            [
                'column'   => 'employee_deduction.employee_id',
                'operator' => '=',
                'value'    => $employeeId
            ],
            [
                'column'   => 'deduction.status',
                'operator' => '='
                'value'    => "'Active'"
            ]
        ];

        $employeeDeductions = $this->employeeDeductionRepository->fetchAll($columns, $filterCriteria);

        if ($employeeDeductions === ActionResult::FAILURE) {
            return ActionResult::FAILURE;
        }

        return empty($employeeDeductions)
            ? []
            : $employeeDeductions['result_set'];
    }

    private function calculateSssContribution(float $salary): array
    {
        $contributionTable = [
            ["range" => [0    , 4249.99 ], "employee_share" => 180.00 , "employer_share" => 390.00 ],
            ["range" => [4250 , 4749.99 ], "employee_share" => 202.50 , "employer_share" => 437.50 ],
            ["range" => [4750 , 5249.99 ], "employee_share" => 225.00 , "employer_share" => 485.00 ],
            ["range" => [5250 , 5749.99 ], "employee_share" => 247.50 , "employer_share" => 532.50 ],
            ["range" => [5750 , 6249.99 ], "employee_share" => 270.00 , "employer_share" => 580.00 ],
            ["range" => [6250 , 6749.99 ], "employee_share" => 292.50 , "employer_share" => 627.50 ],
            ["range" => [6750 , 7249.99 ], "employee_share" => 315.00 , "employer_share" => 675.00 ],
            ["range" => [7250 , 7749.99 ], "employee_share" => 337.50 , "employer_share" => 722.50 ],
            ["range" => [7750 , 8249.99 ], "employee_share" => 360.00 , "employer_share" => 770.00 ],
            ["range" => [8250 , 8749.99 ], "employee_share" => 382.50 , "employer_share" => 817.50 ],
            ["range" => [8750 , 9249.99 ], "employee_share" => 405.00 , "employer_share" => 865.00 ],
            ["range" => [9250 , 9749.99 ], "employee_share" => 427.50 , "employer_share" => 912.50 ],
            ["range" => [9750 , 10249.99], "employee_share" => 450.00 , "employer_share" => 960.00 ],
            ["range" => [10250, 10749.99], "employee_share" => 472.50 , "employer_share" => 1007.50],
            ["range" => [10750, 11249.99], "employee_share" => 495.00 , "employer_share" => 1055.00],
            ["range" => [11250, 11749.99], "employee_share" => 517.50 , "employer_share" => 1102.50],
            ["range" => [11750, 12249.99], "employee_share" => 540.00 , "employer_share" => 1150.00],
            ["range" => [12250, 12749.99], "employee_share" => 562.50 , "employer_share" => 1197.50],
            ["range" => [12750, 13249.99], "employee_share" => 585.00 , "employer_share" => 1245.00],
            ["range" => [13250, 13749.99], "employee_share" => 607.50 , "employer_share" => 1292.50],
            ["range" => [13750, 14249.99], "employee_share" => 630.00 , "employer_share" => 1340.00],
            ["range" => [14250, 14749.99], "employee_share" => 652.50 , "employer_share" => 1387.50],
            ["range" => [14750, 15249.99], "employee_share" => 675.00 , "employer_share" => 1455.00],
            ["range" => [15250, 15749.99], "employee_share" => 697.50 , "employer_share" => 1502.50],
            ["range" => [15750, 16249.99], "employee_share" => 720.00 , "employer_share" => 1550.00],
            ["range" => [16250, 16749.99], "employee_share" => 742.50 , "employer_share" => 1597.50],
            ["range" => [16750, 17249.99], "employee_share" => 765.00 , "employer_share" => 1645.00],
            ["range" => [17250, 17749.99], "employee_share" => 787.50 , "employer_share" => 1692.50],
            ["range" => [17750, 18249.99], "employee_share" => 810.00 , "employer_share" => 1740.00],
            ["range" => [18250, 18749.99], "employee_share" => 832.50 , "employer_share" => 1787.50],
            ["range" => [18750, 19249.99], "employee_share" => 855.00 , "employer_share" => 1835.00],
            ["range" => [19250, 19749.99], "employee_share" => 877.50 , "employer_share" => 1882.50],
            ["range" => [19750, 20249.99], "employee_share" => 900.00 , "employer_share" => 1930.00],
            ["range" => [20250, 20749.99], "employee_share" => 922.50 , "employer_share" => 1977.50],
            ["range" => [20750, 21249.99], "employee_share" => 945.00 , "employer_share" => 2025.00],
            ["range" => [21250, 21749.99], "employee_share" => 967.50 , "employer_share" => 2072.50],
            ["range" => [21750, 22249.99], "employee_share" => 990.00 , "employer_share" => 2120.00],
            ["range" => [22250, 22749.99], "employee_share" => 1012.50, "employer_share" => 2167.50],
            ["range" => [22750, 23249.99], "employee_share" => 1035.00, "employer_share" => 2215.00],
            ["range" => [23250, 23749.99], "employee_share" => 1057.50, "employer_share" => 2262.50],
            ["range" => [23750, 24249.99], "employee_share" => 1080.00, "employer_share" => 2310.00],
            ["range" => [24250, 24749.99], "employee_share" => 1102.50, "employer_share" => 2357.50],
            ["range" => [24750, 25249.99], "employee_share" => 1125.00, "employer_share" => 2405.00],
            ["range" => [25250, 25749.99], "employee_share" => 1147.50, "employer_share" => 2452.50],
            ["range" => [25750, 26249.99], "employee_share" => 1170.00, "employer_share" => 2500.00],
            ["range" => [26250, 26749.99], "employee_share" => 1192.50, "employer_share" => 2547.50],
            ["range" => [26750, 27249.99], "employee_share" => 1215.00, "employer_share" => 2595.00],
            ["range" => [27250, 27749.99], "employee_share" => 1237.50, "employer_share" => 2642.50],
            ["range" => [27750, 28249.99], "employee_share" => 1260.00, "employer_share" => 2690.00],
            ["range" => [28250, 28749.99], "employee_share" => 1282.50, "employer_share" => 2737.50],
            ["range" => [28750, 29249.99], "employee_share" => 1305.00, "employer_share" => 2785.00],
            ["range" => [29250, 29749.99], "employee_share" => 1327.50, "employer_share" => 2832.50],
            ["range" => [29750, "Over"  ], "employee_share" => 1350.00, "employer_share" => 2880.00]
        ];

        foreach ($contributionTable as $row) {
            if ($row['range'][1] === 'Over') {
                if ($salary >= $row['range'][0]) {
                    return [
                        'employee_share' => $row['employee_share'],
                        'employer_share' => $row['employer_share']
                    ];
                }
            } else {
                if ($salary >= $row['range'][0] && $salary <= $row['range'][1]) {
                    return [
                        'employee_share' => $row['employee_share'],
                        'employer_share' => $row['employer_share']
                    ];
                }
            }
        }

        return [];
    }

    private function calculatePhilhealthContribution(float $salary, int $year): array
    {
        $employeeShare = 0.00;
        $employerShare = 0.00;

        if ($year === 2024 || $year === 2025) {
            if ($salary <= 10000.00) {
                $employeeShare = 500.00;
                $employerShare = 500.00;
            } elseif ($salary >= 10000.01 && $salary <= 99999.99) {
                $employeeShare = max(500.00, $salary * 0.05);
                $employerShare = max(500.00, $salary * 0.05);

                if ($employeeShare > 5000.00) {
                    $employeeShare = 5000.00;
                }

                if ($employerShare > 5000.00) {
                    $employerShare = 5000.00;
                }
            }
        }

        return [
            'employee_share' => $employeeShare,
            'employer_share' => $employerShare
        ];
    }

    private function calculatePagibigFundContribution(float $salary): array
    {
        $employeeShare = 0.00;
        $employerShare = 0.00;

        if ($salary <= 1500) {
            $employeeShare = $salary * 0.01;
            $employerShare = $salary * 0.02;
        } else {
            $employeeShare = $salary * 0.02;
            $employerShare = $salary * 0.02;
        }

        return [
            'employeeShare' => $employeeShare,
            'employerShare' => $employerShare
        ];
    }

    private function calculateWithholdingTax(float $compensation, string $frequency): float
    {
        $withholdingTax = 0.00;

        switch ($frequency) {
            case 'daily':
                if ($compensation <= 685.00) {
                    $withholdingTax = 0.00;
                } elseif ($compensation <= 1095.00) {
                    $withholdingTax = ($compensation - 685.00) * 0.15;
                } elseif ($compensation <= 2191.00) {
                    $withholdingTax = 61.65 + ($compensation - 1095.00) * 0.20;
                } elseif ($compensation <= 5478.00) {
                    $withholdingTax = 280.85 + ($compensation - 2191.00) * 0.25;
                } elseif ($compensation <= 21917.00) {
                    $withholdingTax = 1102.60 + ($compensation - 5478.00) * 0.30;
                } else {
                    $withholdingTax = 6034.30 + ($compensation - 21917.00) * 0.35;
                }
                break;

            case 'weekly':
                if ($compensation <= 4808.00) {
                    $withholdingTax = 0.00;
                } elseif ($compensation <= 7691.00) {
                    $withholdingTax = ($compensation - 4808.00) * 0.15;
                } elseif ($compensation <= 15384.00) {
                    $withholdingTax = 432.60 + ($compensation - 7691.00) * 0.20;
                } elseif ($compensation <= 38461.00) {
                    $withholdingTax = 1971.20 + ($compensation - 15384.00) * 0.25;
                } elseif ($compensation <= 153845.00) {
                    $withholdingTax = 7740.45 + ($compensation - 38461.00) * 0.30;
                } else {
                    $withholdingTax = 42355.65 + ($compensation - 153845.00) * 0.35;
                }
                break;

            case 'biweekly':
                if ($compensation <= 9616.00) {
                    $withholdingTax = 0.00;
                } elseif ($compensation <= 15382.00) {
                    $withholdingTax = ($compensation - 9616.00) * 0.15;
                } elseif ($compensation <= 30768.00) {
                    $withholdingTax = 865.20 + ($compensation - 15382.00) * 0.20;
                } elseif ($compensation <= 76922.00) {
                    $withholdingTax = 3942.40 + ($compensation - 30768.00) * 0.25;
                } elseif ($compensation <= 307690.00) {
                    $withholdingTax = 15480.90 + ($compensation - 76922.00) * 0.30;
                } else {
                    $withholdingTax = 84671.30 + ($compensation - 307690.00) * 0.35;
                }
                break;

            case 'semi-monthly':
                if ($compensation <= 10417.00) {
                    $withholdingTax = 0.00;
                } elseif ($compensation <= 16666.00) {
                    $withholdingTax = ($compensation - 10417.00) * 0.15;
                } elseif ($compensation <= 33332.00) {
                    $withholdingTax = 937.50 + ($compensation - 16666.00) * 0.20;
                } elseif ($compensation <= 83332.00) {
                    $withholdingTax = 4270.70 + ($compensation - 33332.00) * 0.25;
                } elseif ($compensation <= 333332.00) {
                    $withholdingTax = 16770.70 + ($compensation - 83332.00) * 0.30;
                } else {
                    $withholdingTax = 91770.70 + ($compensation - 333332.00) * 0.35;
                }
                break;

            case 'monthly':
                if ($compensation <= 20833.00) {
                    $withholdingTax = 0.00;
                } elseif ($compensation <= 33332.00) {
                    $withholdingTax = ($compensation - 20833.00) * 0.15;
                } elseif ($compensation <= 66666.00) {
                    $withholdingTax = 1875.00 + ($compensation - 33332.00) * 0.20;
                } elseif ($compensation <= 166666.00) {
                    $withholdingTax = 8541.80 + ($compensation - 66666.00) * 0.25;
                } elseif ($compensation <= 666666.00) {
                    $withholdingTax = 33541.80 + ($compensation - 166666.00) * 0.30;
                } else {
                    $withholdingTax = 183541.80 + ($compensation - 666666.00) * 0.35;
                }
                break;

            default:
                return "Invalid payment period. Please specify 'daily', 'weekly', 'semi-monthly', or 'monthly'.";
        }

        return round($withholdingTax, 2);
    }

<?php

public function generatePaySlips(PayrollGroup $payrollGroup): array
	{
		$columns = [
			'id'           ,
			'hourly_rate'  ,
			'annual_salary'
		];

		$filterCriteria = [
			[
				'column'   => 'employee.access_role',
				'operator' => '!=',
				'value'    => "'Admin'"
			],
			[
				'column'   => 'employee.payroll_group_id',
				'operator' => '=',
				'value'    => $payrollGroup->getId()
			],
		];

		$employees = $this->employeeRepository->fetchAll($columns, $filterCriteria);

		if ($employees === ActionResult::FAILURE) {
			return [
				'status'  => 'error',
				'message' => ''
			];
		}

		if (empty($employees)) {
			return [
				'status'  => 'error',
				'message' => ''
			];
		}

		$employees = $employees['result_set'];

        $cutoffStartDate = new DateTime($cutoffStartDate);
        $cutoffEndDate   = new DateTime($cutoffEndDate  );

		foreach ($employees as $employee) {
		    $employeeId = $employee['id'];

		    $workSchedules = $this->workScheduleRepository->getEmployeeWorkSchedules(
		        $employeeId,
		        $cutoffStartDate->format('Y-m-d'),
		        $cutoffEndDate->format('Y-m-d')
            );

            $columns = [];

            $filterCriteria = [
                [
                    'column'   => 'work_schedule.employee_id',
                    'operator' => '=',
                    'value'    => $employeeId
                ],
                [
                    'column'   => 'attendance.date',
                    'operator' => '>=',
                    'value'    => $cutoffStartDate->format('Y-m-d')
                ],
                                [
                    'column'   => 'attendance.date',
                    'operator' => '<=',
                    'value'    =>  $cutoffEndDate->format('Y-m-d')
                ]
            ];

            $attendanceRecords = $this->attendanceRepository->fetchAll($columns, $filterCriteria);

            if ($attendanceRecords === ActionResult::FAILURE) {
    			return [
    				'status'  => 'error',
    				'message' => ''
    			];
    		}
		}
	}

    private function fetchEmployeeAllowances(int $employeeId): ActionResult|array
    {
        $columns = [
            'id'                      ,
            'allowance_id'            ,
            'allowance_is_taxable'    ,
            'allowance_frequency'     ,
            'allowance_status'        ,
            'allowance_effective_date',
            'allowance_end_date'      ,
            'amount'
        ];

        $filterCriteria = [
            [
                'column'   => 'employee_allowance.deleted_at',
                'operator' => 'IS NULL'
            ],
            [
                'column'   => 'employee_allowance.employee_id',
                'operator' => '='
                'value'    => $employeeId
            ],
            [
                'column'   => 'allowance.status'
                'operator' => '='
                'value'    => "'Active'"
            ]
        ];

        $employeeAllowances = $this->employeeAllowanceRepository->fetchAll($columns, $filterCriteria);

        if ($employeeAllowances === ActionResult::FAILURE) {
            return ActionResult::FAILURE;
        }

        return empty($employeeAllowances)
            ? []
            : $employeeAllowances['result_set'];
    }


<?php

    public function generatePaySlips(PayrollGroup $payrollGroup, string $cutoffStartDate, string $cutoffEndDate): array|null
	{
		$employeeColumns = [
			'id'           ,
			'job_title_id' ,
			'department_id',
			'hourly_rate'  ,
			'annual_salary'
		];

		$filterCriteria = [
			[
				'column'   => 'employee.access_role',
				'operator' => '!=',
				'value'    => "'Admin'"
			],
			[
				'column'   => 'employee.payroll_group_id',
				'operator' => '=',
				'value'    => $payrollGroup->getId()
			],
		];

		$employees = $this->employeeRepository->fetchAll($employeeColumns, $filterCriteria);

		if ($employees === ActionResult::FAILURE) {
			return [
				'status'  => 'error',
				'message' => 'An unexpected error occurred. Please try again later.'
			];
		}

		if (empty($employees) || empty($employees['result_set'])) {
			return null;
		}

		$employees = $employees['result_set'];

        $cutoffStartDate = new DateTime($cutoffStartDate);
        $cutoffEndDate   = new DateTime($cutoffEndDate  );

		foreach ($employees as $employee) {
		    $employeeId   = $employee['id'           ];
		    $jobTitleId   = $employee['job_title_id' ];
		    $departmentId = $employee['department_id'];

		    $workSchedules = $this->workScheduleRepository->getEmployeeWorkSchedules(
		        $employeeId,
		        $cutoffStartDate->format('Y-m-d'),
		        $cutoffEndDate->format('Y-m-d')
            );

            if ($workSchedules === ActionResult::FAILURE) {
    			return [
    				'status'  => 'error',
    				'message' => 'An unexpected error occurred. Please try again later.'
    			];
    		}

            if ( ! empty($workSchedules)) {
                $attendanceColumns = [];

                $filterCriteria = [
                    [
                        'column'   => 'work_schedule.employee_id',
                        'operator' => '=',
                        'value'    => $employeeId
                    ],
                    [
                        'column'   => 'attendance.date',
                        'operator' => '>=',
                        'value'    => $cutoffStartDate->format('Y-m-d')
                    ],
                                    [
                        'column'   => 'attendance.date',
                        'operator' => '<=',
                        'value'    =>  $cutoffEndDate->format('Y-m-d')
                    ]
                ];

                $attendanceRecords = $this->attendanceRepository->fetchAll($attendanceColumns, $filterCriteria);

                if ($attendanceRecords === ActionResult::FAILURE) {
        			return [
        				'status'  => 'error',
        				'message' => 'An unexpected error occurred. Please try again later.'
        			];
        		}

                if ( ! empty($attendanceRecords)) {
                    $records = [];

                    foreach ($workSchedules as $date => $schedules) {
                        foreach ($schedules as $workSchedule) {
                            $isAttendanceRecordFound = false;

                            foreach ($attendanceRecords as $attendanceRecord) {
                                if ($attendanceRecord['date'] === $date && $attendanceRecord['work_schedule_id'] === $workSchedule['id']) {
                                    $isAttendanceRecordFound = true;

                                    $records[$date][] = [
                                        'work_schedule'     => $workSchedule    ,
                                        'attendance_record' => $attendanceRecord
                                    ];

                                    break;
                                }
                            }

                            if ( ! $isAttendanceRecordFound) {
                                $records[$date][] = [
                                    'work_schedule'     => $workSchedule,
                                    'attendance_record' => []
                                ];
                            }
                        }
                    }

                    $overtimeRateAssignment = new OvertimeRateAssignment(
                        id          : null         ,
                        departmentId: $departmentId,
                        jobTitleId  : $jobTitleId  ,
                        employeeId  : $employeeId
                    );

                    $overtimeRateAssignmentId = $this->overtimeRateAssignmentRepository->findId($overtimeRateAssignment);

                    if ($overtimeRateAssignmentId === ActionResult::FAILURE) {
            			return [
            				'status'  => 'error',
            				'message' => 'An unexpected error occurred. Please try again later.'
            			];
                    }

                    $overtimeRates = $this->overtimeRateRepository->fetchOvertimeRates( (int) $overtimeRateAssignmentId);

                    if ($overtimeRates === ActionResult::FAILURE) {
            			return [
            				'status'  => 'error',
            				'message' => 'An unexpected error occurred. Please try again later.'
            			];
                    }


                }
            }
		}
	}

    private function fetchEmployeeAllowances(int $employeeId): ActionResult|array
    {
        $columns = [
            'id'                      ,
            'allowance_id'            ,
            'allowance_is_taxable'    ,
            'allowance_frequency'     ,
            'allowance_status'        ,
            'allowance_effective_date',
            'allowance_end_date'      ,
            'amount'
        ];

        $filterCriteria = [
            [
                'column'   => 'employee_allowance.deleted_at',
                'operator' => 'IS NULL'
            ],
            [
                'column'   => 'employee_allowance.employee_id',
                'operator' => '='
                'value'    => $employeeId
            ],
            [
                'column'   => 'allowance.status'
                'operator' => '='
                'value'    => "'Active'"
            ]
        ];

        $employeeAllowances = $this->employeeAllowanceRepository->fetchAll($columns, $filterCriteria);

        if ($employeeAllowances === ActionResult::FAILURE) {
            return ActionResult::FAILURE;
        }

        return empty($employeeAllowances)
            ? []
            : $employeeAllowances['result_set'];
    }
